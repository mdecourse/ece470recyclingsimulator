<h1>About</h1>
<h4>研究項目:</h4>
<ol>
<li>在實體或虛擬主機上配置 Ubuntu Desktop 操作系統, 並配置網際應用程式伺服器</li>
<li>能夠透過程式方法建立虛擬環境中的機電資整合系統</li>
<li>能夠透過網際與機器學習手段, 利用網路遠端監控虛擬整合機電資系統</li>
</ol>
<h4>具體工作項目:</h4>
<ol>
<li>利用虛擬主機安裝 Ubuntu Desktop 操作系統, 並在其中配置 cmstemplate 網際內容管理系統, RoboDK, CoppeliaSim, Webots 等系統</li>
<li>利用 Windows 10 上的 Xming, 遠端啟動 RoboDK, CoppeliaSim 與 Webots 等系統.</li>
<li>利用 Python remote API 操控網際應用程式伺服器上的 RoboDK, CoppeliaSim 與 Webots 機電整合場景</li>
<li>利用 Python 程式根據 RoKiSim Industrial Robot 定義 (XML +STL), 將所有 Robot 系統轉入 CoppeliaSim 與 Webots 執行 Forward and Inverse Kinematic 操作</li>
<li>利用機器視覺與學習方法在近端進行機械手臂自動化操作</li>
<li>利用網際架構監控虛實整合機電系統</li>
</ol><h2>網際內容管理</h2>
<p>能夠自己架設<span style="background-color: #ffff99;">網際內容管理系統</span>所需的軟硬體與網路配置後, 再加上遠端 Github 與近端 Fossil SCM 資料同步的分散式版次管理系統整合後, 想要從事哪一類的科技研究, 應該就沒有後顧之憂了, 而且各成員大多時間都能在網路上進行協同, 只有少部分時間必須配合硬體主機的實體維護與配置操作.</p>
<h4>假如將自行架設的主機以付費的主機代管或雲端主機服務取代, 則各成員皆可全時在網路上進行協同.</h4>
<h4>以下是與強化學習及碎片回復有關的參考資料:</h4>
<p style="padding-left: 30px;"><a href="/downloads/Reinforcement Learning - An Introduction.pdf">Reinforcement Learning - An Introduction.pdf</a></p>
<p style="padding-left: 30px;"><a href="/downloads/Playing Atari with Deep Reinforcement Learning.pdf">Playing Atari with Deep Reinforcement Learning.pdf</a></p>
<p style="padding-left: 30px;"><a href="/downloads/Reconstructing Shredded Documents.pdf">Reconstructing Shredded Documents.pdf</a></p>
<p style="padding-left: 30px;"><a href="/downloads/Reconstruction of Shredded Paper Documents byFeature Matching.pdf">Reconstruction of Shredded Paper Documents byFeature Matching.pdf</a></p>
<p style="padding-left: 30px;"><a href="/downloads/Faster_Reconstruction_of_Shredded_Text_Documents_via_Self-Supervised_Deep_Asymmetric_CVPR_2020_paper.pdf">Faster_Reconstruction_of_Shredded_Text_Documents_via_Self-Supervised_Deep_Asymmetric_CVPR_2020_paper.pdf</a></p>
<p style="padding-left: 30px;"><a href="/downloads/Regenerate the Shredded Documents by using Memetic Algorithm.pdf">Regenerate the Shredded Documents by using Memetic Algorithm.pdf</a></p><h2>虛實整合</h2>
<p>透過網際內容管理主機上配置能與實體系統真實對應的模擬環境後, 使用者可以從多台裝置上的瀏覽器監控虛擬或實體機電資整合系統.</p>
<h4>所需技術:</h4>
<ol>
<li>網際內容管理主機上配置虛擬環境</li>
<li>該虛擬機電資整合環境可以透過製造流程成為實體系統</li>
<li>虛擬環境中的場景影像可以串流至使用者網路裝置上的瀏覽器或 APPs</li>
<li>使用者可以監控虛擬或實體機電資整合系統</li>
</ol><h2>機器學習</h2>
<ol>
<li>機器可以透過影像裝置取得外部物件座標系統</li>
<li>電腦可以透過該物件座標系統取放物件</li>
<li>機電資系統可以透過強化學習完成既定工作項目</li>
</ol><h1>pj5073</h1>
<p>這台主機是採用 Ubuntu 20.04 Desktop 最小安裝後, 配置 CMSiMDE 動態網站在 uwsgi + nginx 的 https www server 的環境中啟動, 而靜態網頁則直接配置於 http nginx server.</p>
<p>之後為了讓使用者可以遠端 ssh 至主機, 另外安裝 openssh-server.</p>
<p>Fossil SCM 則透過 stunnel 提供的 https 進行 port 5443 的 serving. 但目前上述動態與靜態 CMSiMDE 並未與近端 Fossil SCM 及遠端 Github 倉儲進行同步整合.</p>
<p>由於這台主機具備桌面系統, 因此使用者可以透過 <a href="https://sourceforge.net/projects/xming/">https://sourceforge.net/projects/xming/</a> 以 X-windows 取得在server 執行的程式畫面, 其中包括 <a href="https://robodk.com/">RoboDK</a> 與 <a href="https://www.coppeliarobotics.com">CoppeliaSim</a>.</p>
<p>上述配置可以搭配:</p>
<p style="padding-left: 30px;"><a href="https://ctmakro.github.io/site/on_learning/rl/vrep.html">https://ctmakro.github.io/site/on_learning/rl/vrep.html</a></p>
<p style="padding-left: 30px;"><a href="https://medium.com/pytorch/robotic-assembly-using-deep-reinforcement-learning-dfd9916c5ad7">https://medium.com/pytorch/robotic-assembly-using-deep-reinforcement-learning-dfd9916c5ad7</a></p>
<p style="padding-left: 30px;"><a href="https://github.com/stepjam/PyRep">https://github.com/stepjam/PyRep</a></p>
<p>進行機電整合系統的機器學習研究.</p>
<p>Changie init.py title to "Pj5073", need to use "sudo systemctl restart cmsimde" to make it work.</p><h2>upgrade</h2>
<p>sudo apt update</p>
<p>sudo apt upgrade</p>
<p>sudo apt dist-upgrade</p>
<p>sudo do-release-upgrade</p>
<p>/etc/update-manager/release-upgrades file</p>
<p>Prompt=lts or normal</p>
<p>因為 Range3 無法在 Ubuntu 20.04 項下的 libqt5core5a 程式庫版本中執行 5.12, 必須升級為 Ubuntu 21.04 才可以安裝 5.15 以上的 libqt5core5a.</p>
<p>2021.05.16 16:59 正在升級為 Ubuntu 21.04 過程中.</p>
<h1>相關技術</h1>
<h2>X Window</h2>
<p>在 Windows 10 中可以使用 <a href="https://sourceforge.net/projects/xming/">Xming </a>X server. 其目的在讓遠端的伺服器執行 GUI 程式時, 能將圖型介面傳送至 X server.</p>
<p>利用 <a href="https://sourceforge.net/projects/xming/">Xming </a>帶出 pj5073.kmol.info 上所執行的程式 GUI 畫面流程:</p>
<ol>
<li>設定以 putty.exe 對 pj5073.kmol.info ssh 連線</li>
<li>連線 session 之 SSH -&gt; Auth -&gt;X11 勾選 enable X11 Forwarding, 並將 X Display location 設為 localhost:0.0, 表示要將程式執行的畫面傳回 X server.</li>
<li>ssh <a href="mailto:user_account@pj5073.kmol.info">user_account@pj5073.kmol.info</a> 連線後, 以 xterm&amp; 背景執行 xterm.</li>
<li>接著以 nautilus&amp; 背景執行 Ubuntu 的 GUI 檔案瀏覽器.</li>
</ol>
<h2>RoboDK</h2>
<h4>Windows 64 位元:</h4>
<p style="padding-left: 30px;"><a href="https://robodk.com/downloads/Install-RoboDK-64-v5.2.3.exe">https://robodk.com/downloads/Install-RoboDK-64-v5.2.3.exe</a></p>
<h4>Mac 64 位元:</h4>
<p style="padding-left: 30px;"><a href="https://robodk.com/downloads/Install-RoboDK.dmg">https://robodk.com/downloads/Install-RoboDK.dmg</a></p>
<h4>Ubuntu 64 位元:</h4>
<p style="padding-left: 30px;"><a href="https://robodk.com/downloads/Install-RoboDK.tar.gz">https://robodk.com/downloads/Install-RoboDK.tar.gz</a></p>
<h4>Raspberry Pi:</h4>
<p style="padding-left: 30px;"><a href="https://robodk.com/downloads/Install-RoboDK-Pi.tar.gz">https://robodk.com/downloads/Install-RoboDK-Pi.tar.gz</a></p>
<h4>Android:</h4>
<p style="padding-left: 30px;"><a href="https://play.google.com/store/apps/details?id=org.robodk.app.sharex">https://play.google.com/store/apps/details?id=org.robodk.app.sharex</a></p>
<h4>iPhone:</h4>
<p style="padding-left: 30px;"><a href="https://apps.apple.com/lc/app/robodk/id1485169308">https://apps.apple.com/lc/app/robodk/id1485169308</a></p>
<h3>RoboDK API</h3>
<h4>get CWD:</h4>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">import os

# Get the current working directory

CWD = os.path.dirname(os.path.realpath(__file__))</pre>
<p><br/>Under Ubuntu</p>
<p>/usr/local/lib/python3.8/dist-packages/robolink/robolink.py</p>
<p>and</p>
<p>/usr/local/lib/python3.8/dist-packages/robodk/robodk.py</p>
<p>replaced with the newest source codes of <a href="https://github.com/RoboDK/RoboDK-API/tree/master/Python">https://github.com/RoboDK/RoboDK-API/tree/master/Python</a></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">from robolink import *
from robodk import *

import os

dir_path = os.path.dirname(os.path.realpath(__file__))
print(dir_path)
# Calculate pyramid coordinate

def pyramid_calc(BALLS_SIDE=4):
    """Calculate a list of points (ball center) as if the balls were place in a pyramid"""
    #the number of balls can be calculated as: int(BALLS_SIDE*(BALLS_SIDE+1)*(2*BALLS_SIDE+1)/6)
    BALL_DIAMETER = 100
    xyz_list = []
    sqrt2 = 2**(0.5)
    for h in range(BALLS_SIDE):
        for i in range(BALLS_SIDE-h):
            for j in range(BALLS_SIDE-h):
                height = h*BALL_DIAMETER/sqrt2 + BALL_DIAMETER/2
                xyz_list = xyz_list + [[i*BALL_DIAMETER + (h+1)*BALL_DIAMETER*0.5, j*BALL_DIAMETER + (h+1)*BALL_DIAMETER*0.5, height]]
    return xyz_list
    

# Make a list of positions to place the objects
balls_list = pyramid_calc(4)

#print(len(frame1_list))
# 4*4 = 16
# 3*3 = 9
# 2*2 = 4
# 1+4+9+16 = 30

# height 50*sqrt(2)
'''
[

[50.0, 50.0, 50.0], [50.0, 150.0, 50.0], [50.0, 250.0, 50.0], [50.0, 350.0, 50.0], 

[150.0, 50.0, 50.0], [150.0, 150.0, 50.0], [150.0, 250.0, 50.0], [150.0, 350.0, 50.0], 

[250.0, 50.0, 50.0], [250.0, 150.0, 50.0], [250.0, 250.0, 50.0], [250.0, 350.0, 50.0], 

[350.0, 50.0, 50.0], [350.0, 150.0, 50.0], [350.0, 250.0, 50.0], [350.0, 350.0, 50.0], 


[100.0, 100.0, 120.71067811865474], [100.0, 200.0, 120.71067811865474], [100.0, 300.0, 120.71067811865474], 

[200.0, 100.0, 120.71067811865474], [200.0, 200.0, 120.71067811865474], [200.0, 300.0, 120.71067811865474], 

[300.0, 100.0, 120.71067811865474], [300.0, 200.0, 120.71067811865474], [300.0, 300.0, 120.71067811865474], 


[150.0, 150.0, 191.42135623730948], [150.0, 250.0, 191.42135623730948], 

[250.0, 150.0, 191.42135623730948], [250.0, 250.0, 191.42135623730948], 


[200.0, 200.0, 262.13203435596427]

]

'''
# https://github.com/RoboDK/RoboDK-API/blob/master/Python/robolink.py
# robodk_path variable to specify location of RoboDK.exe
# under Ubuntu can not use "-NEWINSTANCE"
'''
start_robodk.sh content
LD_LIBRARY_PATH="/home/yen/RoboDK/bin/lib"
export LD_LIBRARY_PATH
/home/yen/RoboDK/bin/RoboDK
'''
RDK = Robolink(robodk_path="/home/yen/start_robodk.sh",args=["-SKIPINI", "-EXIT_LAST_COM"])
# Add robot and the accompanied Base coordinate
print(dir_path + '/Fanuc-M-710iC-50.robot')
# relative directory or absolute directory will work for AddFile under Ubuntu
#robot = RDK.AddFile(r"/home/yen/github/wcm2021/downloads/robodk/pick_and_place_kmol_mac/Fanuc-M-710iC-50.robot")
robot = RDK.AddFile('Fanuc-M-710iC-50.robot')
# Get the default robot base frame
robot_frame = RDK.Item('Fanuc M-710iC/50 Base')
# Move the base frame to the origin
robot_frame.setPose(transl(0,0,0))

# Add a tool to an existing robot:
tool = RDK.AddFile(dir_path + '/MainTool.tool', robot)

# Add table 1
table1_frame = RDK.AddFrame('Table 1')
table1_frame.setPose(transl(807.766544,-963.699898,41.478944))
table1_stl = RDK.AddFile(dir_path + '/Table.stl', table1_frame)

# Add table 2
table2_frame = RDK.AddFrame('Table 2')
table2_frame.setPose(transl(926.465508,337.151529,94.871928))
table2_stl = RDK.AddFile(dir_path + '/Table.stl', table2_frame)

# Add balls
# create a list with 30 elements
balls = [None for _ in range(30)]
layer = [16, 9, 4, 1]
count = 0
for i in range(len(balls_list)):
    # transl(balls_list)
    balls[i] = RDK.AddFile('./ball.stl', table2_frame)
    balls[i].setPose(transl(balls_list[i]))
    count = count + 1
    if count &lt;= 16:
        balls[i].setColor([1, 0, 0])
    elif count &gt; 16 and count &lt;= 25:
        balls[i].setColor([0, 1, 0])
    elif count &gt; 25 and count &lt;=29:
        balls[i].setColor([1, 1, 0])
    else:
        balls[i].setColor([0, 0, 1])
</pre>
<h3>Pick and Place</h3>
<h4>Use RoboDK Python API create Pick and Place simulation:</h4>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">from robolink import *
from robodk import *

import os

dir_path = os.path.dirname(os.path.realpath(__file__))
print(dir_path)
# Calculate pyramid coordinate

# Setup global parameters
BALL_DIAMETER = 100 # diameter of one ball
APPROACH = 100      # approach distance to grab each part, in mm
nTCPs = 6           # number of TCP's in the tool

def pyramid_calc(BALLS_SIDE=4):
    """Calculate a list of points (ball center) as if the balls were place in a pyramid"""
    #the number of balls can be calculated as: int(BALLS_SIDE*(BALLS_SIDE+1)*(2*BALLS_SIDE+1)/6)
    #BALL_DIAMETER = 100
    xyz_list = []
    sqrt2 = 2**(0.5)
    for h in range(BALLS_SIDE):
        for i in range(BALLS_SIDE-h):
            for j in range(BALLS_SIDE-h):
                height = h*BALL_DIAMETER/sqrt2 + BALL_DIAMETER/2
                xyz_list = xyz_list + [[i*BALL_DIAMETER + (h+1)*BALL_DIAMETER*0.5, j*BALL_DIAMETER + (h+1)*BALL_DIAMETER*0.5, height]]
    return xyz_list
    
def TCP_On(toolitem, tcp_id):
    """Attach the closest object to the toolitem Htool pose,
    furthermore, it will output appropriate function calls on the generated robot program (call to TCP_On)"""
    toolitem.AttachClosest()
    toolitem.RDK().RunMessage('Set air valve %i on' % (tcp_id+1))
    toolitem.RDK().RunProgram('TCP_On(%i)' % (tcp_id+1));
        
def TCP_Off(toolitem, tcp_id, itemleave=0):
    """Detaches the closest object attached to the toolitem Htool pose,
    furthermore, it will output appropriate function calls on the generated robot program (call to TCP_Off)"""
    toolitem.DetachAll(itemleave)
    toolitem.RDK().RunMessage('Set air valve %i off' % (tcp_id+1))
    toolitem.RDK().RunProgram('TCP_Off(%i)' % (tcp_id+1));

# Make a list of positions to place the objects
balls_list = pyramid_calc(4)

#print(len(frame1_list))
# 4*4 = 16
# 3*3 = 9
# 2*2 = 4
# 1+4+9+16 = 30

# height 50*sqrt(2)
'''
[

[50.0, 50.0, 50.0], [50.0, 150.0, 50.0], [50.0, 250.0, 50.0], [50.0, 350.0, 50.0], 

[150.0, 50.0, 50.0], [150.0, 150.0, 50.0], [150.0, 250.0, 50.0], [150.0, 350.0, 50.0], 

[250.0, 50.0, 50.0], [250.0, 150.0, 50.0], [250.0, 250.0, 50.0], [250.0, 350.0, 50.0], 

[350.0, 50.0, 50.0], [350.0, 150.0, 50.0], [350.0, 250.0, 50.0], [350.0, 350.0, 50.0], 


[100.0, 100.0, 120.71067811865474], [100.0, 200.0, 120.71067811865474], [100.0, 300.0, 120.71067811865474], 

[200.0, 100.0, 120.71067811865474], [200.0, 200.0, 120.71067811865474], [200.0, 300.0, 120.71067811865474], 

[300.0, 100.0, 120.71067811865474], [300.0, 200.0, 120.71067811865474], [300.0, 300.0, 120.71067811865474], 


[150.0, 150.0, 191.42135623730948], [150.0, 250.0, 191.42135623730948], 

[250.0, 150.0, 191.42135623730948], [250.0, 250.0, 191.42135623730948], 


[200.0, 200.0, 262.13203435596427]

]

'''
# https://github.com/RoboDK/RoboDK-API/blob/master/Python/robolink.py
# robodk_path variable to specify location of RoboDK.exe
# under Ubuntu can not use "-NEWINSTANCE"
'''
start_robodk.sh content
LD_LIBRARY_PATH="/home/yen/RoboDK/bin/lib"
export LD_LIBRARY_PATH
/home/yen/RoboDK/bin/RoboDK
'''
RDK = Robolink(robodk_path="/home/yen/start_robodk.sh",args=["-SKIPINI", "-EXIT_LAST_COM"])
# Add robot and the accompanied Base coordinate
print(dir_path + '/Fanuc-M-710iC-50.robot')
# relative directory or absolute directory will work for AddFile under Ubuntu
#robot = RDK.AddFile(r"/home/yen/github/wcm2021/downloads/robodk/pick_and_place_kmol_mac/Fanuc-M-710iC-50.robot")
robot = RDK.AddFile('Fanuc-M-710iC-50.robot')
# Get the default robot base frame
robot_frame = RDK.Item('Fanuc M-710iC/50 Base')
# Move the base frame to the origin
robot_frame.setPose(transl(0,0,0))

# Add a tool to an existing robot:
tool = RDK.AddFile(dir_path + '/MainTool.tool', robot)

# Add table 1
table1_frame = RDK.AddFrame('Table 1')
table1_frame.setPose(transl(807.766544,-963.699898,41.478944))
table1_stl = RDK.AddFile(dir_path + '/Table.stl', table1_frame)

# Add table 2
table2_frame = RDK.AddFrame('Table 2')
table2_frame.setPose(transl(926.465508,337.151529,94.871928))
table2_stl = RDK.AddFile(dir_path + '/Table.stl', table2_frame)
     
# Calculate tool frames for the suction cup tool of 6 suction cups
TCP_list = []
for i in range(nTCPs):
    TCPi_pose = transl(0,0,100)*rotz((360/nTCPs)*i*pi/180)*transl(125,0,0)*roty(pi/2)
    TCPi = robot.AddTool(TCPi_pose, 'TCP %i' % (i+1))
    TCP_list.append(TCPi)

TCP_0 = TCP_list[0]

# Turn on automatic rendering
RDK.Render(True)

# Add balls
# create a list with 30 elements
balls = [None for _ in range(30)]
layer = [16, 9, 4, 1]
count = 0
for i in range(len(balls_list)):
    # transl(balls_list)
    balls[i] = RDK.AddFile('./ball.stl', table1_frame)
    balls[i].setPose(transl(balls_list[i]))
    count = count + 1
    if count &lt;= 16:
        balls[i].setColor([1, 0, 0])
    elif count &gt; 16 and count &lt;= 25:
        balls[i].setColor([0, 1, 0])
    elif count &gt; 25 and count &lt;=29:
        balls[i].setColor([1, 1, 0])
    else:
        balls[i].setColor([0, 0, 1])

# Make a list of positions to place the objects
# ball_list is the same as frame1_list
frame1_list = pyramid_calc(4)
frame2_list = pyramid_calc(4)

# Move balls 
robot.setPoseTool(TCP_list[0])
nballs_frame1 = len(frame1_list)
nballs_frame2 = len(frame2_list)
idTake = nballs_frame1 - 1
idLeave = 0
idTCP = 0

target_app_frame = transl(2*BALL_DIAMETER, 2*BALL_DIAMETER, 4*BALL_DIAMETER)*roty(pi)*transl(0,0,-APPROACH)

# frame1 is the same as table1_frame
frame1 = RDK.Item('Table 1')
frame2 = RDK.Item('Table 2')

while idTake &gt;= 0:
    # ------------------------------------------------------------------
    # first priority: grab as many balls as possible
    # the tool is empty at this point, so take as many balls as possible (up to a maximum of 6 -&gt; nTCPs)
    ntake = min(nTCPs, idTake + 1)

    # approach to frame 1
    robot.setPoseFrame(frame1)
    robot.setPoseTool(TCP_0)
    robot.MoveJ([0,0,0,0,10,-200])
    robot.MoveJ(target_app_frame)

    # grab ntake balls from frame1
    for i in range(ntake):
        TCPi = TCP_list[i]
        robot.setPoseTool(TCPi)
        # calculate target wrt frame1: rotation about Y is needed since Z and X axis are inverted
        target = transl(frame1_list[idTake])*roty(pi)*rotx(30*pi/180)
        target_app = target*transl(0,0,-APPROACH)
        idTake = idTake - 1        
        robot.MoveL(target_app)
        robot.MoveL(target)
        TCP_On(TCPi, i)
        robot.MoveL(target_app)
 
    # ------------------------------------------------------------------
    # second priority: unload the tool     
    # approach to frame2 and place the tool balls into table2
    robot.setPoseTool(TCP_0)
    robot.MoveJ(target_app_frame)
    robot.MoveJ([0,0,0,0,10,-200])
    robot.setPoseFrame(frame2)    
    robot.MoveJ(target_app_frame)
    for i in range(ntake):
        TCPi = TCP_list[i]
        robot.setPoseTool(TCPi)
        if idLeave &gt; nballs_frame2-1:
            raise Exception("No room left to place objects in Table 2")

        # calculate target wrt frame1: rotation of 180 about Y is needed since Z and X axis are inverted
        target = transl(frame2_list[idLeave])*roty(pi)*rotx(30*pi/180)
        target_app = target*transl(0,0,-APPROACH)
        idLeave = idLeave + 1        
        robot.MoveL(target_app)
        robot.MoveL(target)
        TCP_Off(TCPi, i, frame2)
        robot.MoveL(target_app)

    robot.MoveJ(target_app_frame)

# Move home when the robot finishes
robot.MoveJ([0,0,0,0,10,-200])
</pre>
<p></p>
<h2>CoppeliaSim</h2>
<h4>Educational version:</h4>
<h4>Windows:</h4>
<p style="padding-left: 30px;"><a href="https://www.coppeliarobotics.com/files/CoppeliaSim_Edu_V4_1_0_Setup.exe">https://www.coppeliarobotics.com/files/CoppeliaSim_Edu_V4_1_0_Setup.exe</a></p>
<p style="padding-left: 30px;"><a href="https://www.coppeliarobotics.com/files/CoppeliaSim_Edu_V4_1_0_Win.zip">https://www.coppeliarobotics.com/files/CoppeliaSim_Edu_V4_1_0_Win.zip</a></p>
<h4>Mac:</h4>
<p style="padding-left: 30px;"><a href="https://www.coppeliarobotics.com/files/CoppeliaSim_Edu_V4_1_0_Mac.zip">https://www.coppeliarobotics.com/files/CoppeliaSim_Edu_V4_1_0_Mac.zip</a></p>
<h4>Ubuntu:</h4>
<p style="padding-left: 30px;"><a href="https://www.coppeliarobotics.com/files/CoppeliaSim_Edu_V4_1_0_Ubuntu20_04.tar.xz">https://www.coppeliarobotics.com/files/CoppeliaSim_Edu_V4_1_0_Ubuntu20_04.tar.xz</a></p>
<h2>Arduino</h2>
<h4>UnoArduSim:</h4>
<p style="padding-left: 30px;"><a href="https://www.sites.google.com/site/unoardusim/services">https://www.sites.google.com/site/unoardusim/services</a></p>
<p style="padding-left: 30px;"><a href="/downloads/UnoArduSimV2.9.1.zip">UnoArduSimV2.9.1.zip</a></p>
<h4>Picsimlab:</h4>
<p style="padding-left: 30px;"><a href="https://github.com/lcgamboa/picsimlab">https://github.com/lcgamboa/picsimlab</a></p>
<p></p>
<p style="padding-left: 30px;"></p>
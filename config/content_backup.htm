<h1>About</h1>
<h4>五專部專題題目:</h4>
<h4 style="padding-left: 30px;"><span style="background-color: #ffff99;">網際內容管理系統在精密機械工程教學與研究上的應用</span></h4>
<h4 style="padding-left: 30px;">Application of Web-based Content Management Systems in Teaching and Research of Precision Mechanical Engineering</h4>
<h4 style="padding-left: 30px;">專題動機:</h4>
<p style="padding-left: 60px;">探討如何利用 <a href="https://www.fossil-scm.org">Fossil SCM</a> 虛擬與實體伺服器, 讓五專精密機械工程科相關師生, 得以透過學校配發的 @gm 帳號登入, 並在網際內容管理系統中進行知識管理與互動, 擬藉此提升課程教學與專題研究效益.</p>
<h4 style="padding-left: 30px;">研究步驟:</h4>
<p style="padding-left: 60px;">從 Windows 與 Ubuntu 中編譯 <a href="https://www.fossil-scm.org">Fossil SCM</a> 套件開始, 分別取得 client 與 server 端的可執行檔案後, 將 <a href="https://www.fossil-scm.org">Fossil SCM</a> 安裝配置在一台實體或虛擬主機上, 利用 Python + <a href="https://flask.palletsprojects.com/en/2.0.x/">Flask</a> 著手編寫 <a href="https://oauth.net/2/">Oauth2</a> 網際程式介面, 讓所有相關成員得以自建倉儲與網際內容管理系統, 之後再分門別類, 根據精密機械工程科學會的任務編組, 利用網際內容管理系統提供相關服務.</p>
<h4 style="padding-left: 30px;">預計成果:</h4>
<ol>
<li>參與 eng.nfu.edu.tw 網域伺服器 (DNS) 與 G Suite 系統管理.</li>
<li>在 Ubuntu 虛擬主機上, 完成以 <a href="https://www.fossil-scm.org">Fossil SCM</a> 架設 pj5073.eng.nfu.edu.tw 精密機械工程科學會網站.</li>
<li>能讓獲得許可之相關人員, 透過 @gm 帳號登入科學會網站, 在各班對應網站上進行 Github 上同步網際內容管理維護或互動討論.</li>
<li>專題報告 pdf 檔案, 能夠在 github.com/mdecourse/pj5073 倉儲中的 pdf 分支, 以 Github Actions 流程發布.</li>
<li>專題簡報可直接在 mde.tw/pj5073/reveal/ 中發布.</li>
</ol>
<h4 style="padding-left: 30px;">組員:</h4>
<p style="padding-left: 60px;">50733105</p>
<p style="padding-left: 60px;">50733144</p>
<p style="padding-left: 60px;">50733146</p>
<p style="padding-left: 60px;">50733152</p>
<h4>四技部專題題目:</h4>
<h4 style="padding-left: 30px;"><span style="background-color: #ffff99;">深度強化學習在行動機器人運動學上之應用</span></h4>
<h4 style="padding-left: 30px;">Application of Deep Reinforcement Learning in Kinematics of Mobile Robots</h4>
<h4 style="padding-left: 30px;">專題動機:</h4>
<p style="padding-left: 60px;">藉由研究 <a href="https://github.com/mdecourse/pj2022/tree/main/ece470_project">ECE470 專案</a>中行動機器人如何在 <a href="https://www.coppeliarobotics.com/">CoppeliaSim</a> 場景中, 利用 Python remote API, 以機器視覺輔助完成避障與取放特定物件的專案內容, 並在 <a href="https://arxiv.org/pdf/2101.05325.pdf">ref1</a> 與 <a href="https://github.com/robot-learning-freiburg/kinematic-feasibility-rl">ref2</a> 參考資料的引導下, 研究分析深度強化學習架構該如何在行動機器人運動學上進行應用.</p>
<h4 style="padding-left: 30px;">研究步驟:</h4>
<ol>
<li>將 <a href="https://github.com/mdecourse/pj2022/tree/main/ece470_project">ECE470 專案</a>內容分別配置於 Windows 與 Ubuntu 環境中, 重現 Python remote API 控制場景, 完成避障與取放特定物件任務.</li>
<li>延伸 Python remote API, 改用 <a href="https://www.coppeliarobotics.com/helpFiles/en/b0RemoteApiOverview.htm">B0-based remote API</a> 完成避障與取放特定物件任務.</li>
<li>延伸上述 <a href="https://www.coppeliarobotics.com/">CoppeliaSim</a> 控制場景, 在 Ubuntu 上以 <a href="https://www.coppeliarobotics.com/helpFiles/en/commandLine.htm">headless</a> 啟動, 並將場景影像以 <a href="https://flask.palletsprojects.com/en/2.0.x/">Flask</a> 串流至 client 端瀏覽器.</li>
<li>在 Ubuntu 實體與虛擬主機上建立 pj2022.kmol.info 主機, 設法編寫轉檔程式 (主要修改 init.py, config/config 檔案設定內容), 讓自架主機上的倉儲內容能夠同時支援近端 (同步內容推送至 Github, Gitlab, Bitbucket 與 Heroku) 與 <a href="https://uwsgi-docs.readthedocs.io/en/latest/">uwsgi</a> 伺服.</li>
<li>研究如何利用機器視覺與深度強化學習 (<a href="https://link.springer.com/book/10.1007/978-981-15-4095-0">ref1</a>, <a href="https://link.springer.com/book/10.1007/978-981-13-8285-7">ref2</a>, <a href="https://github.com/p-christ/Deep-Reinforcement-Learning-Algorithms-with-PyTorch">ref3</a>)提升避障與取放特定物件效能.</li>
</ol>
<h4 style="padding-left: 30px;">預計成果:</h4>
<ol>
<li>完成 pj2022.kmol.info 主機架設, 使用者可從瀏覽器登入行動機器人場景執行監控.</li>
<li>pj2022 專題網站內容可同步至 Github Pages, Gitlab Pages, 自架 <a href="https://www.fossil-scm.org">Fossil SCM</a> 主機與 Heroku 主機.</li>
<li>專題報告 pdf 檔案, 能夠在 github.com/mdecourse/pj2022 倉儲中的 pdf 分支, 以 Github Actions 流程發布.</li>
<li>專題報告內容能直接透過 Github Actions 套用 <a href="https://www.ieee.org/conferences/publishing/templates.html">IEEE 論文格式</a>進行 5-7 頁論文 Release 發布.</li>
<li>專題簡報可直接在 mde.tw/pj2022/reveal/ 中發布.</li>
</ol>
<h4 style="padding-left: 30px;">組員:</h4>
<p style="padding-left: 60px;">40823116</p>
<p style="padding-left: 60px;">40823131</p>
<p style="padding-left: 60px;">40823152</p>
<p style="padding-left: 60px;">40823153</p>
<hr/>
<h4>工作站室虛擬主機:</h4>
<p style="padding-left: 30px;">nginx: sudo /etc/init.d/nginx restart</p>
<p style="padding-left: 30px;">uwsgi: sudo systemctl restart cmsimde</p>
<p style="padding-left: 30px;">fossil scm: sudo /etc/init.d/stunnel4 restart</p>
<h4>研究項目:</h4>
<ol>
<li>在實體或虛擬主機上配置 Ubuntu Desktop 操作系統, 並配置網際應用程式伺服器</li>
<li>能夠透過程式方法建立虛擬環境中的機電資整合系統</li>
<li>能夠透過網際與機器學習手段, 利用網路遠端監控虛擬整合機電資系統</li>
</ol>
<h4>具體工作項目:</h4>
<ol>
<li>利用虛擬主機安裝 Ubuntu Desktop 操作系統, 並在其中配置 cmstemplate 網際內容管理系統, RoboDK, CoppeliaSim, Webots 等系統</li>
<li>利用 Windows 10 上的 Xming, 遠端啟動 RoboDK, CoppeliaSim 與 Webots 等系統.</li>
<li>利用 Python remote API 操控網際應用程式伺服器上的 RoboDK, CoppeliaSim 與 Webots 機電整合場景</li>
<li>利用 Python 程式根據 RoKiSim Industrial Robot 定義 (XML +STL), 將所有 Robot 系統轉入 CoppeliaSim 與 Webots 執行 Forward and Inverse Kinematic 操作</li>
<li>利用機器視覺與學習方法在近端進行機械手臂自動化操作</li>
<li>利用網際架構監控虛實整合機電系統</li>
</ol>
<p>了解 <a href="/downloads/RoKiSim.7z">RoKiSim.7z</a> 中有關 CAD_Robots 目錄中有關 XML 與 STL 組成 Robot 的定義, 然後根據 <a href="/downloads/abbirm.simscene.xml.zip">abbirm.simscene.xml.zip</a> 中 CoppeliaSim XML 檔案格式, 以程式方法將所有 Robots 轉為 CoppeliaSim 場景中的 ttm 模型. 以執行 Forward and Inverse Knimatic 運動操作.</p><h2>網際內容管理</h2>
<p>能夠自己架設<span style="background-color: #ffff99;">網際內容管理系統</span>所需的軟硬體與網路配置後, 再加上遠端 Github 與近端 Fossil SCM 資料同步的分散式版次管理系統整合後, 想要從事哪一類的科技研究, 應該就沒有後顧之憂了, 而且各成員大多時間都能在網路上進行協同, 只有少部分時間必須配合硬體主機的實體維護與配置操作.</p>
<h4>假如將自行架設的主機以付費的主機代管或雲端主機服務取代, 則各成員皆可全時在網路上進行協同.</h4>
<h4>以下是與強化學習及碎片回復有關的參考資料:</h4>
<p style="padding-left: 30px;"><a href="/downloads/Reinforcement Learning - An Introduction.pdf">Reinforcement Learning - An Introduction.pdf</a></p>
<p style="padding-left: 30px;"><a href="/downloads/Playing Atari with Deep Reinforcement Learning.pdf">Playing Atari with Deep Reinforcement Learning.pdf</a></p>
<p style="padding-left: 30px;"><a href="/downloads/Reconstructing Shredded Documents.pdf">Reconstructing Shredded Documents.pdf</a></p>
<p style="padding-left: 30px;"><a href="/downloads/Reconstruction of Shredded Paper Documents byFeature Matching.pdf">Reconstruction of Shredded Paper Documents byFeature Matching.pdf</a></p>
<p style="padding-left: 30px;"><a href="/downloads/Faster_Reconstruction_of_Shredded_Text_Documents_via_Self-Supervised_Deep_Asymmetric_CVPR_2020_paper.pdf">Faster_Reconstruction_of_Shredded_Text_Documents_via_Self-Supervised_Deep_Asymmetric_CVPR_2020_paper.pdf</a></p>
<p style="padding-left: 30px;"><a href="/downloads/Regenerate the Shredded Documents by using Memetic Algorithm.pdf">Regenerate the Shredded Documents by using Memetic Algorithm.pdf</a></p><h2>虛實整合</h2>
<p>透過網際內容管理主機上配置能與實體系統真實對應的模擬環境後, 使用者可以從多台裝置上的瀏覽器監控虛擬或實體機電資整合系統.</p>
<h4>所需技術:</h4>
<ol>
<li>網際內容管理主機上配置虛擬環境</li>
<li>該虛擬機電資整合環境可以透過製造流程成為實體系統</li>
<li>虛擬環境中的場景影像可以串流至使用者網路裝置上的瀏覽器或 APPs</li>
<li>使用者可以監控虛擬或實體機電資整合系統</li>
</ol><h2>機器學習</h2>
<ol>
<li>機器可以透過影像裝置取得外部物件座標系統</li>
<li>電腦可以透過該物件座標系統取放物件</li>
<li>機電資系統可以透過強化學習完成既定工作項目</li>
</ol><h1>pj2022</h1>
<p><a href="http://mally.stanford.edu/~sr/computing/basic-unix.html">http://mally.stanford.edu/~sr/computing/basic-unix.html</a></p>
<p>這台主機是採用 Ubuntu 20.04 Desktop 最小安裝後, 配置 CMSiMDE 動態網站在 uwsgi + nginx 的 https www server 的環境中啟動, 而靜態網頁則直接配置於 http nginx server.</p>
<p>之後為了讓使用者可以遠端 ssh 至主機, 另外安裝 openssh-server.</p>
<p>Fossil SCM 則透過 stunnel 提供的 https 進行 port 5443 的 serving. 但目前上述動態與靜態 CMSiMDE 並未與近端 Fossil SCM 及遠端 Github 倉儲進行同步整合.</p>
<p>由於這台主機具備桌面系統, 因此使用者可以透過 <a href="https://sourceforge.net/projects/xming/">https://sourceforge.net/projects/xming/</a> 以 X-windows 取得在server 執行的程式畫面, 其中包括 <a href="https://robodk.com/">RoboDK</a> 與 <a href="https://www.coppeliarobotics.com">CoppeliaSim</a>.</p>
<p>上述配置可以搭配:</p>
<p style="padding-left: 30px;"><a href="https://ctmakro.github.io/site/on_learning/rl/vrep.html">https://ctmakro.github.io/site/on_learning/rl/vrep.html</a></p>
<p style="padding-left: 30px;"><a href="https://medium.com/pytorch/robotic-assembly-using-deep-reinforcement-learning-dfd9916c5ad7">https://medium.com/pytorch/robotic-assembly-using-deep-reinforcement-learning-dfd9916c5ad7</a></p>
<p style="padding-left: 30px;"><a href="https://github.com/stepjam/PyRep">https://github.com/stepjam/PyRep</a></p>
<p>進行機電整合系統的機器學習研究.</p>
<p>Change init.py title to "Pj5073", need to use "sudo systemctl restart cmsimde" to make it work.</p><h2>upgrade</h2>
<p>sudo apt update</p>
<p>sudo apt upgrade</p>
<p>sudo apt dist-upgrade</p>
<p>sudo do-release-upgrade</p>
<p>/etc/update-manager/release-upgrades file</p>
<p>Prompt=lts or normal</p>
<p>因為 Range3 無法在 Ubuntu 20.04 項下的 libqt5core5a 程式庫版本中執行 5.12, 必須升級為 Ubuntu 21.04 才可以安裝 5.15 以上的 libqt5core5a.</p>
<p>2021.05.16 16:59 正在升級為 Ubuntu 21.04 過程中.</p>
<h1>強化學習</h1>
<h4>Deep Reinforcement Learning</h4>
<p><a href="/downloads/Introduction to Deep Reinforcement Learning0.pdf">Introduction to Deep Reinforcement Learning0.pdf</a></p>
<p><a href="/downloads/Tutorial of Deep Reinforcement Learning.pdf">Tutorial of Deep Reinforcement Learning.pdf</a></p>
<p><a href="/downloads/An Introduction to Deep Reinforcement Learning.pdf">An Introduction to Deep Reinforcement Learning.pdf</a></p>
<p><a href="/downloads/An Introduction To Deep Reinforcement Learning2.pdf">An Introduction To Deep Reinforcement Learning2.pdf</a></p>
<p><a href="/downloads/An Introduction to Deep Reinforcement Learning3.pdf">An Introduction to Deep Reinforcement Learning3.pdf</a></p>
<p><a href="/downloads/Deep Reinforcement Learning with InteractiveFeedback in a Human–Robot Environment.pdf">Deep Reinforcement Learning with InteractiveFeedback in a Human–Robot Environment.pdf</a></p>
<p><a href="/downloads/A Collision Avoidance Method Based on DeepReinforcement Learning.pdf">A Collision Avoidance Method Based on DeepReinforcement Learning.pdf</a></p>
<p><a href="/downloads/Experimental investigations of a highlymaneuverable mobile omniwheel robot.pdf">Experimental investigations of a highlymaneuverable mobile omniwheel robot.pdf</a></p>
<p><a href="https://ieeexplore.ieee.org/document/7989385">Deep reinforcement learning for robotic manipulation with asynchronous off-policy updates</a> (在校園網路中下載)</p><h1>相關技術</h1>
<p><a href="http://kinematic-rl.cs.uni-freiburg.de/">Learning Kinematic Feasibility through Reinforcement Learning</a></p>
<p style="padding-left: 30px;"><a href="/downloads/Learning Kinematic Feasibility for MobileManipulation through Deep Reinforcement Learning.pdf">Learning Kinematic Feasibility for MobileManipulation through Deep Reinforcement Learning.pdf</a></p>
<p style="padding-left: 30px;"><a href="https://github.com/robot-learning-freiburg/kinematic-feasibility-rl">https://github.com/robot-learning-freiburg/kinematic-feasibility-rl</a></p>
<p style="padding-left: 30px;"><a href="https://rl.uni-freiburg.de/demos-datasets-software">https://rl.uni-freiburg.de/demos-datasets-software</a></p>
<p>Fundamentals of Manipulator Calibration: <a href="https://core.ac.uk/download/pdf/36732657.pdf">https://core.ac.uk/download/pdf/36732657.pdf</a></p><h2>X Window</h2>
<p>在 Windows 10 中可以使用 <a href="https://sourceforge.net/projects/xming/">Xming </a>X server. 其目的在讓遠端的伺服器執行 GUI 程式時, 能將圖型介面傳送至 X server.</p>
<p>利用 <a href="https://sourceforge.net/projects/xming/">Xming </a>帶出 pj5073.kmol.info 上所執行的程式 GUI 畫面流程:</p>
<ol>
<li>設定以 putty.exe 對 pj5073.kmol.info ssh 連線</li>
<li>連線 session 之 SSH -&gt; Auth -&gt;X11 勾選 enable X11 Forwarding, 並將 X Display location 設為 localhost:0.0, 表示要將程式執行的畫面傳回 X server.</li>
<li>ssh <a href="mailto:user_account@pj5073.kmol.info">user_account@pj5073.kmol.info</a> 連線後, 以 xterm&amp; 背景執行 xterm.</li>
<li>接著以 nautilus&amp; 背景執行 Ubuntu 的 GUI 檔案瀏覽器.</li>
</ol>
<h2>RoboDK</h2>
<h4>Windows 64 位元:</h4>
<p style="padding-left: 30px;"><a href="https://robodk.com/downloads/Install-RoboDK-64-v5.2.3.exe">https://robodk.com/downloads/Install-RoboDK-64-v5.2.3.exe</a></p>
<h4>Mac 64 位元:</h4>
<p style="padding-left: 30px;"><a href="https://robodk.com/downloads/Install-RoboDK.dmg">https://robodk.com/downloads/Install-RoboDK.dmg</a></p>
<h4>Ubuntu 64 位元:</h4>
<p style="padding-left: 30px;"><a href="https://robodk.com/downloads/Install-RoboDK.tar.gz">https://robodk.com/downloads/Install-RoboDK.tar.gz</a></p>
<h4>Raspberry Pi:</h4>
<p style="padding-left: 30px;"><a href="https://robodk.com/downloads/Install-RoboDK-Pi.tar.gz">https://robodk.com/downloads/Install-RoboDK-Pi.tar.gz</a></p>
<h4>Android:</h4>
<p style="padding-left: 30px;"><a href="https://play.google.com/store/apps/details?id=org.robodk.app.sharex">https://play.google.com/store/apps/details?id=org.robodk.app.sharex</a></p>
<h4>iPhone:</h4>
<p style="padding-left: 30px;"><a href="https://apps.apple.com/lc/app/robodk/id1485169308">https://apps.apple.com/lc/app/robodk/id1485169308</a></p>
<h3>RoboDK API</h3>
<h4>get CWD:</h4>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">import os

# Get the current working directory

CWD = os.path.dirname(os.path.realpath(__file__))</pre>
<p><br/>Under Ubuntu</p>
<p>/usr/local/lib/python3.8/dist-packages/robolink/robolink.py</p>
<p>and</p>
<p>/usr/local/lib/python3.8/dist-packages/robodk/robodk.py</p>
<p>replaced with the newest source codes of <a href="https://github.com/RoboDK/RoboDK-API/tree/master/Python">https://github.com/RoboDK/RoboDK-API/tree/master/Python</a></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">from robolink import *
from robodk import *

import os

dir_path = os.path.dirname(os.path.realpath(__file__))
print(dir_path)
# Calculate pyramid coordinate

def pyramid_calc(BALLS_SIDE=4):
    """Calculate a list of points (ball center) as if the balls were place in a pyramid"""
    #the number of balls can be calculated as: int(BALLS_SIDE*(BALLS_SIDE+1)*(2*BALLS_SIDE+1)/6)
    BALL_DIAMETER = 100
    xyz_list = []
    sqrt2 = 2**(0.5)
    for h in range(BALLS_SIDE):
        for i in range(BALLS_SIDE-h):
            for j in range(BALLS_SIDE-h):
                height = h*BALL_DIAMETER/sqrt2 + BALL_DIAMETER/2
                xyz_list = xyz_list + [[i*BALL_DIAMETER + (h+1)*BALL_DIAMETER*0.5, j*BALL_DIAMETER + (h+1)*BALL_DIAMETER*0.5, height]]
    return xyz_list
    

# Make a list of positions to place the objects
balls_list = pyramid_calc(4)

#print(len(frame1_list))
# 4*4 = 16
# 3*3 = 9
# 2*2 = 4
# 1+4+9+16 = 30

# height 50*sqrt(2)
'''
[

[50.0, 50.0, 50.0], [50.0, 150.0, 50.0], [50.0, 250.0, 50.0], [50.0, 350.0, 50.0], 

[150.0, 50.0, 50.0], [150.0, 150.0, 50.0], [150.0, 250.0, 50.0], [150.0, 350.0, 50.0], 

[250.0, 50.0, 50.0], [250.0, 150.0, 50.0], [250.0, 250.0, 50.0], [250.0, 350.0, 50.0], 

[350.0, 50.0, 50.0], [350.0, 150.0, 50.0], [350.0, 250.0, 50.0], [350.0, 350.0, 50.0], 


[100.0, 100.0, 120.71067811865474], [100.0, 200.0, 120.71067811865474], [100.0, 300.0, 120.71067811865474], 

[200.0, 100.0, 120.71067811865474], [200.0, 200.0, 120.71067811865474], [200.0, 300.0, 120.71067811865474], 

[300.0, 100.0, 120.71067811865474], [300.0, 200.0, 120.71067811865474], [300.0, 300.0, 120.71067811865474], 


[150.0, 150.0, 191.42135623730948], [150.0, 250.0, 191.42135623730948], 

[250.0, 150.0, 191.42135623730948], [250.0, 250.0, 191.42135623730948], 


[200.0, 200.0, 262.13203435596427]

]

'''
# https://github.com/RoboDK/RoboDK-API/blob/master/Python/robolink.py
# robodk_path variable to specify location of RoboDK.exe
# under Ubuntu can not use "-NEWINSTANCE"
'''
start_robodk.sh content
LD_LIBRARY_PATH="/home/yen/RoboDK/bin/lib"
export LD_LIBRARY_PATH
/home/yen/RoboDK/bin/RoboDK
'''
RDK = Robolink(robodk_path="/home/yen/start_robodk.sh",args=["-SKIPINI", "-EXIT_LAST_COM"])
# Add robot and the accompanied Base coordinate
print(dir_path + '/Fanuc-M-710iC-50.robot')
# relative directory or absolute directory will work for AddFile under Ubuntu
#robot = RDK.AddFile(r"/home/yen/github/wcm2021/downloads/robodk/pick_and_place_kmol_mac/Fanuc-M-710iC-50.robot")
robot = RDK.AddFile('Fanuc-M-710iC-50.robot')
# Get the default robot base frame
robot_frame = RDK.Item('Fanuc M-710iC/50 Base')
# Move the base frame to the origin
robot_frame.setPose(transl(0,0,0))

# Add a tool to an existing robot:
tool = RDK.AddFile(dir_path + '/MainTool.tool', robot)

# Add table 1
table1_frame = RDK.AddFrame('Table 1')
table1_frame.setPose(transl(807.766544,-963.699898,41.478944))
table1_stl = RDK.AddFile(dir_path + '/Table.stl', table1_frame)

# Add table 2
table2_frame = RDK.AddFrame('Table 2')
table2_frame.setPose(transl(926.465508,337.151529,94.871928))
table2_stl = RDK.AddFile(dir_path + '/Table.stl', table2_frame)

# Add balls
# create a list with 30 elements
balls = [None for _ in range(30)]
layer = [16, 9, 4, 1]
count = 0
for i in range(len(balls_list)):
    # transl(balls_list)
    balls[i] = RDK.AddFile('./ball.stl', table2_frame)
    balls[i].setPose(transl(balls_list[i]))
    count = count + 1
    if count &lt;= 16:
        balls[i].setColor([1, 0, 0])
    elif count &gt; 16 and count &lt;= 25:
        balls[i].setColor([0, 1, 0])
    elif count &gt; 25 and count &lt;=29:
        balls[i].setColor([1, 1, 0])
    else:
        balls[i].setColor([0, 0, 1])
</pre>
<h3>Pick and Place</h3>
<h4>Use RoboDK Python API create Pick and Place simulation:</h4>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">from robolink import *
from robodk import *

import os

dir_path = os.path.dirname(os.path.realpath(__file__))
print(dir_path)
# Calculate pyramid coordinate

# Setup global parameters
BALL_DIAMETER = 100 # diameter of one ball
APPROACH = 100      # approach distance to grab each part, in mm
nTCPs = 6           # number of TCP's in the tool

def pyramid_calc(BALLS_SIDE=4):
    """Calculate a list of points (ball center) as if the balls were place in a pyramid"""
    #the number of balls can be calculated as: int(BALLS_SIDE*(BALLS_SIDE+1)*(2*BALLS_SIDE+1)/6)
    #BALL_DIAMETER = 100
    xyz_list = []
    sqrt2 = 2**(0.5)
    for h in range(BALLS_SIDE):
        for i in range(BALLS_SIDE-h):
            for j in range(BALLS_SIDE-h):
                height = h*BALL_DIAMETER/sqrt2 + BALL_DIAMETER/2
                xyz_list = xyz_list + [[i*BALL_DIAMETER + (h+1)*BALL_DIAMETER*0.5, j*BALL_DIAMETER + (h+1)*BALL_DIAMETER*0.5, height]]
    return xyz_list
    
def TCP_On(toolitem, tcp_id):
    """Attach the closest object to the toolitem Htool pose,
    furthermore, it will output appropriate function calls on the generated robot program (call to TCP_On)"""
    toolitem.AttachClosest()
    toolitem.RDK().RunMessage('Set air valve %i on' % (tcp_id+1))
    toolitem.RDK().RunProgram('TCP_On(%i)' % (tcp_id+1));
        
def TCP_Off(toolitem, tcp_id, itemleave=0):
    """Detaches the closest object attached to the toolitem Htool pose,
    furthermore, it will output appropriate function calls on the generated robot program (call to TCP_Off)"""
    toolitem.DetachAll(itemleave)
    toolitem.RDK().RunMessage('Set air valve %i off' % (tcp_id+1))
    toolitem.RDK().RunProgram('TCP_Off(%i)' % (tcp_id+1));

# Make a list of positions to place the objects
balls_list = pyramid_calc(4)

#print(len(frame1_list))
# 4*4 = 16
# 3*3 = 9
# 2*2 = 4
# 1+4+9+16 = 30

# height 50*sqrt(2)
'''
[

[50.0, 50.0, 50.0], [50.0, 150.0, 50.0], [50.0, 250.0, 50.0], [50.0, 350.0, 50.0], 

[150.0, 50.0, 50.0], [150.0, 150.0, 50.0], [150.0, 250.0, 50.0], [150.0, 350.0, 50.0], 

[250.0, 50.0, 50.0], [250.0, 150.0, 50.0], [250.0, 250.0, 50.0], [250.0, 350.0, 50.0], 

[350.0, 50.0, 50.0], [350.0, 150.0, 50.0], [350.0, 250.0, 50.0], [350.0, 350.0, 50.0], 


[100.0, 100.0, 120.71067811865474], [100.0, 200.0, 120.71067811865474], [100.0, 300.0, 120.71067811865474], 

[200.0, 100.0, 120.71067811865474], [200.0, 200.0, 120.71067811865474], [200.0, 300.0, 120.71067811865474], 

[300.0, 100.0, 120.71067811865474], [300.0, 200.0, 120.71067811865474], [300.0, 300.0, 120.71067811865474], 


[150.0, 150.0, 191.42135623730948], [150.0, 250.0, 191.42135623730948], 

[250.0, 150.0, 191.42135623730948], [250.0, 250.0, 191.42135623730948], 


[200.0, 200.0, 262.13203435596427]

]

'''
# https://github.com/RoboDK/RoboDK-API/blob/master/Python/robolink.py
# robodk_path variable to specify location of RoboDK.exe
# under Ubuntu can not use "-NEWINSTANCE"
'''
start_robodk.sh content
LD_LIBRARY_PATH="/home/yen/RoboDK/bin/lib"
export LD_LIBRARY_PATH
/home/yen/RoboDK/bin/RoboDK
'''
RDK = Robolink(robodk_path="/home/yen/start_robodk.sh",args=["-SKIPINI", "-EXIT_LAST_COM"])
# Add robot and the accompanied Base coordinate
print(dir_path + '/Fanuc-M-710iC-50.robot')
# relative directory or absolute directory will work for AddFile under Ubuntu
#robot = RDK.AddFile(r"/home/yen/github/wcm2021/downloads/robodk/pick_and_place_kmol_mac/Fanuc-M-710iC-50.robot")
robot = RDK.AddFile('Fanuc-M-710iC-50.robot')
# Get the default robot base frame
robot_frame = RDK.Item('Fanuc M-710iC/50 Base')
# Move the base frame to the origin
robot_frame.setPose(transl(0,0,0))

# Add a tool to an existing robot:
tool = RDK.AddFile(dir_path + '/MainTool.tool', robot)

# Add table 1
table1_frame = RDK.AddFrame('Table 1')
table1_frame.setPose(transl(807.766544,-963.699898,41.478944))
table1_stl = RDK.AddFile(dir_path + '/Table.stl', table1_frame)

# Add table 2
table2_frame = RDK.AddFrame('Table 2')
table2_frame.setPose(transl(926.465508,337.151529,94.871928))
table2_stl = RDK.AddFile(dir_path + '/Table.stl', table2_frame)
     
# Calculate tool frames for the suction cup tool of 6 suction cups
TCP_list = []
for i in range(nTCPs):
    TCPi_pose = transl(0,0,100)*rotz((360/nTCPs)*i*pi/180)*transl(125,0,0)*roty(pi/2)
    TCPi = robot.AddTool(TCPi_pose, 'TCP %i' % (i+1))
    TCP_list.append(TCPi)

TCP_0 = TCP_list[0]

# Turn on automatic rendering
RDK.Render(True)

# Add balls
# create a list with 30 elements
balls = [None for _ in range(30)]
layer = [16, 9, 4, 1]
count = 0
for i in range(len(balls_list)):
    # transl(balls_list)
    balls[i] = RDK.AddFile('./ball.stl', table1_frame)
    balls[i].setPose(transl(balls_list[i]))
    count = count + 1
    if count &lt;= 16:
        balls[i].setColor([1, 0, 0])
    elif count &gt; 16 and count &lt;= 25:
        balls[i].setColor([0, 1, 0])
    elif count &gt; 25 and count &lt;=29:
        balls[i].setColor([1, 1, 0])
    else:
        balls[i].setColor([0, 0, 1])

# Make a list of positions to place the objects
# ball_list is the same as frame1_list
frame1_list = pyramid_calc(4)
frame2_list = pyramid_calc(4)

# Move balls 
robot.setPoseTool(TCP_list[0])
nballs_frame1 = len(frame1_list)
nballs_frame2 = len(frame2_list)
idTake = nballs_frame1 - 1
idLeave = 0
idTCP = 0

target_app_frame = transl(2*BALL_DIAMETER, 2*BALL_DIAMETER, 4*BALL_DIAMETER)*roty(pi)*transl(0,0,-APPROACH)

# frame1 is the same as table1_frame
frame1 = RDK.Item('Table 1')
frame2 = RDK.Item('Table 2')

while idTake &gt;= 0:
    # ------------------------------------------------------------------
    # first priority: grab as many balls as possible
    # the tool is empty at this point, so take as many balls as possible (up to a maximum of 6 -&gt; nTCPs)
    ntake = min(nTCPs, idTake + 1)

    # approach to frame 1
    robot.setPoseFrame(frame1)
    robot.setPoseTool(TCP_0)
    robot.MoveJ([0,0,0,0,10,-200])
    robot.MoveJ(target_app_frame)

    # grab ntake balls from frame1
    for i in range(ntake):
        TCPi = TCP_list[i]
        robot.setPoseTool(TCPi)
        # calculate target wrt frame1: rotation about Y is needed since Z and X axis are inverted
        target = transl(frame1_list[idTake])*roty(pi)*rotx(30*pi/180)
        target_app = target*transl(0,0,-APPROACH)
        idTake = idTake - 1        
        robot.MoveL(target_app)
        robot.MoveL(target)
        TCP_On(TCPi, i)
        robot.MoveL(target_app)
 
    # ------------------------------------------------------------------
    # second priority: unload the tool     
    # approach to frame2 and place the tool balls into table2
    robot.setPoseTool(TCP_0)
    robot.MoveJ(target_app_frame)
    robot.MoveJ([0,0,0,0,10,-200])
    robot.setPoseFrame(frame2)    
    robot.MoveJ(target_app_frame)
    for i in range(ntake):
        TCPi = TCP_list[i]
        robot.setPoseTool(TCPi)
        if idLeave &gt; nballs_frame2-1:
            raise Exception("No room left to place objects in Table 2")

        # calculate target wrt frame1: rotation of 180 about Y is needed since Z and X axis are inverted
        target = transl(frame2_list[idLeave])*roty(pi)*rotx(30*pi/180)
        target_app = target*transl(0,0,-APPROACH)
        idLeave = idLeave + 1        
        robot.MoveL(target_app)
        robot.MoveL(target)
        TCP_Off(TCPi, i, frame2)
        robot.MoveL(target_app)

    robot.MoveJ(target_app_frame)

# Move home when the robot finishes
robot.MoveJ([0,0,0,0,10,-200])
</pre>
<p></p>
<h2>CoppeliaSim</h2>
<h4>Educational version:</h4>
<h4>Windows:</h4>
<p style="padding-left: 30px;"><a href="https://www.coppeliarobotics.com/files/CoppeliaSim_Edu_V4_1_0_Setup.exe">https://www.coppeliarobotics.com/files/CoppeliaSim_Edu_V4_1_0_Setup.exe</a></p>
<p style="padding-left: 30px;"><a href="https://www.coppeliarobotics.com/files/CoppeliaSim_Edu_V4_1_0_Win.zip">https://www.coppeliarobotics.com/files/CoppeliaSim_Edu_V4_1_0_Win.zip</a></p>
<h4>Mac:</h4>
<p style="padding-left: 30px;"><a href="https://www.coppeliarobotics.com/files/CoppeliaSim_Edu_V4_1_0_Mac.zip">https://www.coppeliarobotics.com/files/CoppeliaSim_Edu_V4_1_0_Mac.zip</a></p>
<h4>Ubuntu:</h4>
<p style="padding-left: 30px;"><a href="https://www.coppeliarobotics.com/files/CoppeliaSim_Edu_V4_1_0_Ubuntu20_04.tar.xz">https://www.coppeliarobotics.com/files/CoppeliaSim_Edu_V4_1_0_Ubuntu20_04.tar.xz</a></p>
<h2>Arduino</h2>
<h4>UnoArduSim:</h4>
<p style="padding-left: 30px;"><a href="https://www.sites.google.com/site/unoardusim/services">https://www.sites.google.com/site/unoardusim/services</a></p>
<p style="padding-left: 30px;"><a href="/downloads/UnoArduSimV2.9.1.zip">UnoArduSimV2.9.1.zip</a></p>
<h4>Picsimlab:</h4>
<p style="padding-left: 30px;"><a href="https://github.com/lcgamboa/picsimlab">https://github.com/lcgamboa/picsimlab</a></p>
<p></p>
<p style="padding-left: 30px;"></p>
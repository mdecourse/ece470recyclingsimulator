var tipuesearch = {"pages": [{'title': 'About', 'text': '工作站室虛擬主機: \n nginx: sudo /etc/init.d/nginx restart \n uwsgi: sudo systemctl restart cmsimde \n fossil scm: sudo /etc/init.d/stunnel4 restart \n 研究項目: \n \n 在實體或虛擬主機上配置 Ubuntu Desktop 操作系統, 並配置網際應用程式伺服器 \n 能夠透過程式方法建立虛擬環境中的機電資整合系統 \n 能夠透過網際與機器學習手段, 利用網路遠端監控虛擬整合機電資系統 \n \n 具體工作項目: \n \n 利用虛擬主機安裝 Ubuntu Desktop 操作系統, 並在其中配置 cmstemplate 網際內容管理系統, RoboDK, CoppeliaSim, Webots 等系統 \n 利用 Windows 10 上的 Xming, 遠端啟動 RoboDK, CoppeliaSim 與 Webots 等系統. \n 利用 Python remote API 操控網際應用程式伺服器上的 RoboDK, CoppeliaSim 與 Webots 機電整合場景 \n 利用 Python 程式根據 RoKiSim Industrial Robot 定義 (XML +STL), 將所有 Robot 系統轉入 CoppeliaSim 與 Webots 執行 Forward and Inverse Kinematic 操作 \n 利用機器視覺與學習方法在近端進行機械手臂自動化操作 \n 利用網際架構監控虛實整合機電系統 \n \n 了解  RoKiSim.7z  中有關 CAD_Robots 目錄中有關 XML 與 STL 組成 Robot 的定義, 然後根據  abbirm.simscene.xml.zip  中 CoppeliaSim XML 檔案格式, 以程式方法將所有 Robots 轉為 CoppeliaSim 場景中的 ttm 模型. 以執行 Forward and Inverse Knimatic 運動操作.', 'tags': '', 'url': 'About.html'}, {'title': '網際內容管理', 'text': '能夠自己架設 網際內容管理系統 所需的軟硬體與網路配置後, 再加上遠端 Github 與近端 Fossil SCM 資料同步的分散式版次管理系統整合後, 想要從事哪一類的科技研究, 應該就沒有後顧之憂了, 而且各成員大多時間都能在網路上進行協同, 只有少部分時間必須配合硬體主機的實體維護與配置操作. \n 假如將自行架設的主機以付費的主機代管或雲端主機服務取代, 則各成員皆可全時在網路上進行協同. \n 以下是與強化學習及碎片回復有關的參考資料: \n Reinforcement Learning - An Introduction.pdf \n Playing Atari with Deep Reinforcement Learning.pdf \n Reconstructing Shredded Documents.pdf \n Reconstruction of Shredded Paper Documents byFeature Matching.pdf \n Faster_Reconstruction_of_Shredded_Text_Documents_via_Self-Supervised_Deep_Asymmetric_CVPR_2020_paper.pdf \n Regenerate the Shredded Documents by using Memetic Algorithm.pdf', 'tags': '', 'url': '網際內容管理.html'}, {'title': '虛實整合', 'text': '透過網際內容管理主機上配置能與實體系統真實對應的模擬環境後, 使用者可以從多台裝置上的瀏覽器監控虛擬或實體機電資整合系統. \n 所需技術: \n \n 網際內容管理主機上配置虛擬環境 \n 該虛擬機電資整合環境可以透過製造流程成為實體系統 \n 虛擬環境中的場景影像可以串流至使用者網路裝置上的瀏覽器或 APPs \n 使用者可以監控虛擬或實體機電資整合系統 \n', 'tags': '', 'url': '虛實整合.html'}, {'title': '機器學習', 'text': '\n 機器可以透過影像裝置取得外部物件座標系統 \n 電腦可以透過該物件座標系統取放物件 \n 機電資系統可以透過強化學習完成既定工作項目 \n', 'tags': '', 'url': '機器學習.html'}, {'title': 'pj2022', 'text': 'http://mally.stanford.edu/~sr/computing/basic-unix.html \n 這台主機是採用 Ubuntu 20.04 Desktop 最小安裝後, 配置 CMSiMDE 動態網站在 uwsgi + nginx 的 https www server 的環境中啟動, 而靜態網頁則直接配置於 http nginx server. \n 之後為了讓使用者可以遠端 ssh 至主機, 另外安裝 openssh-server. \n Fossil SCM 則透過 stunnel 提供的 https 進行 port 5443 的 serving. 但目前上述動態與靜態 CMSiMDE 並未與近端 Fossil SCM 及遠端 Github 倉儲進行同步整合. \n 由於這台主機具備桌面系統, 因此使用者可以透過  https://sourceforge.net/projects/xming/  以 X-windows 取得在server 執行的程式畫面, 其中包括  RoboDK  與  CoppeliaSim . \n 上述配置可以搭配: \n https://ctmakro.github.io/site/on_learning/rl/vrep.html \n https://medium.com/pytorch/robotic-assembly-using-deep-reinforcement-learning-dfd9916c5ad7 \n https://github.com/stepjam/PyRep \n 進行機電整合系統的機器學習研究. \n Changie init.py title to "Pj5073", need to use "sudo systemctl restart cmsimde" to make it work.', 'tags': '', 'url': 'pj2022.html'}, {'title': 'upgrade', 'text': 'sudo apt update \n sudo apt upgrade \n sudo apt dist-upgrade \n sudo do-release-upgrade \n /etc/update-manager/release-upgrades file \n Prompt=lts or normal \n 因為 Range3 無法在 Ubuntu 20.04 項下的 libqt5core5a 程式庫版本中執行 5.12, 必須升級為 Ubuntu 21.04 才可以安裝 5.15 以上的 libqt5core5a. \n 2021.05.16 16:59 正在升級為 Ubuntu 21.04 過程中. \n', 'tags': '', 'url': 'upgrade.html'}, {'title': '相關技術', 'text': 'Fundamentals of Manipulator Calibration:  https://core.ac.uk/download/pdf/36732657.pdf  ', 'tags': '', 'url': '相關技術.html'}, {'title': 'X Window', 'text': '在 Windows 10 中可以使用  Xming  X server. 其目的在讓遠端的伺服器執行 GUI 程式時, 能將圖型介面傳送至 X server. \n 利用  Xming  帶出 pj5073.kmol.info 上所執行的程式 GUI 畫面流程: \n \n 設定以 putty.exe 對 pj5073.kmol.info ssh 連線 \n 連線 session 之 SSH -> Auth ->X11 勾選 enable X11 Forwarding, 並將 X Display location 設為 localhost:0.0, 表示要將程式執行的畫面傳回 X server. \n ssh  user_account@pj5073.kmol.info  連線後, 以 xterm& 背景執行 xterm. \n 接著以 nautilus& 背景執行 Ubuntu 的 GUI 檔案瀏覽器. \n \n', 'tags': '', 'url': 'X Window.html'}, {'title': 'RoboDK', 'text': 'Windows 64 位元: \n https://robodk.com/downloads/Install-RoboDK-64-v5.2.3.exe \n Mac 64 位元: \n https://robodk.com/downloads/Install-RoboDK.dmg \n Ubuntu 64 位元: \n https://robodk.com/downloads/Install-RoboDK.tar.gz \n Raspberry Pi: \n https://robodk.com/downloads/Install-RoboDK-Pi.tar.gz \n Android: \n https://play.google.com/store/apps/details?id=org.robodk.app.sharex \n iPhone: \n https://apps.apple.com/lc/app/robodk/id1485169308 \n', 'tags': '', 'url': 'RoboDK.html'}, {'title': 'RoboDK API', 'text': 'get CWD: \n import os\n\n# Get the current working directory\n\nCWD = os.path.dirname(os.path.realpath(__file__)) \n Under Ubuntu \n /usr/local/lib/python3.8/dist-packages/robolink/robolink.py \n and \n /usr/local/lib/python3.8/dist-packages/robodk/robodk.py \n replaced with the newest source codes of  https://github.com/RoboDK/RoboDK-API/tree/master/Python \n from robolink import *\nfrom robodk import *\n\nimport os\n\ndir_path = os.path.dirname(os.path.realpath(__file__))\nprint(dir_path)\n# Calculate pyramid coordinate\n\ndef pyramid_calc(BALLS_SIDE=4):\n    """Calculate a list of points (ball center) as if the balls were place in a pyramid"""\n    #the number of balls can be calculated as: int(BALLS_SIDE*(BALLS_SIDE+1)*(2*BALLS_SIDE+1)/6)\n    BALL_DIAMETER = 100\n    xyz_list = []\n    sqrt2 = 2**(0.5)\n    for h in range(BALLS_SIDE):\n        for i in range(BALLS_SIDE-h):\n            for j in range(BALLS_SIDE-h):\n                height = h*BALL_DIAMETER/sqrt2 + BALL_DIAMETER/2\n                xyz_list = xyz_list + [[i*BALL_DIAMETER + (h+1)*BALL_DIAMETER*0.5, j*BALL_DIAMETER + (h+1)*BALL_DIAMETER*0.5, height]]\n    return xyz_list\n    \n\n# Make a list of positions to place the objects\nballs_list = pyramid_calc(4)\n\n#print(len(frame1_list))\n# 4*4 = 16\n# 3*3 = 9\n# 2*2 = 4\n# 1+4+9+16 = 30\n\n# height 50*sqrt(2)\n\'\'\'\n[\n\n[50.0, 50.0, 50.0], [50.0, 150.0, 50.0], [50.0, 250.0, 50.0], [50.0, 350.0, 50.0], \n\n[150.0, 50.0, 50.0], [150.0, 150.0, 50.0], [150.0, 250.0, 50.0], [150.0, 350.0, 50.0], \n\n[250.0, 50.0, 50.0], [250.0, 150.0, 50.0], [250.0, 250.0, 50.0], [250.0, 350.0, 50.0], \n\n[350.0, 50.0, 50.0], [350.0, 150.0, 50.0], [350.0, 250.0, 50.0], [350.0, 350.0, 50.0], \n\n\n[100.0, 100.0, 120.71067811865474], [100.0, 200.0, 120.71067811865474], [100.0, 300.0, 120.71067811865474], \n\n[200.0, 100.0, 120.71067811865474], [200.0, 200.0, 120.71067811865474], [200.0, 300.0, 120.71067811865474], \n\n[300.0, 100.0, 120.71067811865474], [300.0, 200.0, 120.71067811865474], [300.0, 300.0, 120.71067811865474], \n\n\n[150.0, 150.0, 191.42135623730948], [150.0, 250.0, 191.42135623730948], \n\n[250.0, 150.0, 191.42135623730948], [250.0, 250.0, 191.42135623730948], \n\n\n[200.0, 200.0, 262.13203435596427]\n\n]\n\n\'\'\'\n# https://github.com/RoboDK/RoboDK-API/blob/master/Python/robolink.py\n# robodk_path variable to specify location of RoboDK.exe\n# under Ubuntu can not use "-NEWINSTANCE"\n\'\'\'\nstart_robodk.sh content\nLD_LIBRARY_PATH="/home/yen/RoboDK/bin/lib"\nexport LD_LIBRARY_PATH\n/home/yen/RoboDK/bin/RoboDK\n\'\'\'\nRDK = Robolink(robodk_path="/home/yen/start_robodk.sh",args=["-SKIPINI", "-EXIT_LAST_COM"])\n# Add robot and the accompanied Base coordinate\nprint(dir_path + \'/Fanuc-M-710iC-50.robot\')\n# relative directory or absolute directory will work for AddFile under Ubuntu\n#robot = RDK.AddFile(r"/home/yen/github/wcm2021/downloads/robodk/pick_and_place_kmol_mac/Fanuc-M-710iC-50.robot")\nrobot = RDK.AddFile(\'Fanuc-M-710iC-50.robot\')\n# Get the default robot base frame\nrobot_frame = RDK.Item(\'Fanuc M-710iC/50 Base\')\n# Move the base frame to the origin\nrobot_frame.setPose(transl(0,0,0))\n\n# Add a tool to an existing robot:\ntool = RDK.AddFile(dir_path + \'/MainTool.tool\', robot)\n\n# Add table 1\ntable1_frame = RDK.AddFrame(\'Table 1\')\ntable1_frame.setPose(transl(807.766544,-963.699898,41.478944))\ntable1_stl = RDK.AddFile(dir_path + \'/Table.stl\', table1_frame)\n\n# Add table 2\ntable2_frame = RDK.AddFrame(\'Table 2\')\ntable2_frame.setPose(transl(926.465508,337.151529,94.871928))\ntable2_stl = RDK.AddFile(dir_path + \'/Table.stl\', table2_frame)\n\n# Add balls\n# create a list with 30 elements\nballs = [None for _ in range(30)]\nlayer = [16, 9, 4, 1]\ncount = 0\nfor i in range(len(balls_list)):\n    # transl(balls_list)\n    balls[i] = RDK.AddFile(\'./ball.stl\', table2_frame)\n    balls[i].setPose(transl(balls_list[i]))\n    count = count + 1\n    if count <= 16:\n        balls[i].setColor([1, 0, 0])\n    elif count > 16 and count <= 25:\n        balls[i].setColor([0, 1, 0])\n    elif count > 25 and count <=29:\n        balls[i].setColor([1, 1, 0])\n    else:\n        balls[i].setColor([0, 0, 1])\n \n', 'tags': '', 'url': 'RoboDK API.html'}, {'title': 'Pick and Place', 'text': 'Use RoboDK Python API create Pick and Place simulation: \n from robolink import *\nfrom robodk import *\n\nimport os\n\ndir_path = os.path.dirname(os.path.realpath(__file__))\nprint(dir_path)\n# Calculate pyramid coordinate\n\n# Setup global parameters\nBALL_DIAMETER = 100 # diameter of one ball\nAPPROACH = 100      # approach distance to grab each part, in mm\nnTCPs = 6           # number of TCP\'s in the tool\n\ndef pyramid_calc(BALLS_SIDE=4):\n    """Calculate a list of points (ball center) as if the balls were place in a pyramid"""\n    #the number of balls can be calculated as: int(BALLS_SIDE*(BALLS_SIDE+1)*(2*BALLS_SIDE+1)/6)\n    #BALL_DIAMETER = 100\n    xyz_list = []\n    sqrt2 = 2**(0.5)\n    for h in range(BALLS_SIDE):\n        for i in range(BALLS_SIDE-h):\n            for j in range(BALLS_SIDE-h):\n                height = h*BALL_DIAMETER/sqrt2 + BALL_DIAMETER/2\n                xyz_list = xyz_list + [[i*BALL_DIAMETER + (h+1)*BALL_DIAMETER*0.5, j*BALL_DIAMETER + (h+1)*BALL_DIAMETER*0.5, height]]\n    return xyz_list\n    \ndef TCP_On(toolitem, tcp_id):\n    """Attach the closest object to the toolitem Htool pose,\n    furthermore, it will output appropriate function calls on the generated robot program (call to TCP_On)"""\n    toolitem.AttachClosest()\n    toolitem.RDK().RunMessage(\'Set air valve %i on\' % (tcp_id+1))\n    toolitem.RDK().RunProgram(\'TCP_On(%i)\' % (tcp_id+1));\n        \ndef TCP_Off(toolitem, tcp_id, itemleave=0):\n    """Detaches the closest object attached to the toolitem Htool pose,\n    furthermore, it will output appropriate function calls on the generated robot program (call to TCP_Off)"""\n    toolitem.DetachAll(itemleave)\n    toolitem.RDK().RunMessage(\'Set air valve %i off\' % (tcp_id+1))\n    toolitem.RDK().RunProgram(\'TCP_Off(%i)\' % (tcp_id+1));\n\n# Make a list of positions to place the objects\nballs_list = pyramid_calc(4)\n\n#print(len(frame1_list))\n# 4*4 = 16\n# 3*3 = 9\n# 2*2 = 4\n# 1+4+9+16 = 30\n\n# height 50*sqrt(2)\n\'\'\'\n[\n\n[50.0, 50.0, 50.0], [50.0, 150.0, 50.0], [50.0, 250.0, 50.0], [50.0, 350.0, 50.0], \n\n[150.0, 50.0, 50.0], [150.0, 150.0, 50.0], [150.0, 250.0, 50.0], [150.0, 350.0, 50.0], \n\n[250.0, 50.0, 50.0], [250.0, 150.0, 50.0], [250.0, 250.0, 50.0], [250.0, 350.0, 50.0], \n\n[350.0, 50.0, 50.0], [350.0, 150.0, 50.0], [350.0, 250.0, 50.0], [350.0, 350.0, 50.0], \n\n\n[100.0, 100.0, 120.71067811865474], [100.0, 200.0, 120.71067811865474], [100.0, 300.0, 120.71067811865474], \n\n[200.0, 100.0, 120.71067811865474], [200.0, 200.0, 120.71067811865474], [200.0, 300.0, 120.71067811865474], \n\n[300.0, 100.0, 120.71067811865474], [300.0, 200.0, 120.71067811865474], [300.0, 300.0, 120.71067811865474], \n\n\n[150.0, 150.0, 191.42135623730948], [150.0, 250.0, 191.42135623730948], \n\n[250.0, 150.0, 191.42135623730948], [250.0, 250.0, 191.42135623730948], \n\n\n[200.0, 200.0, 262.13203435596427]\n\n]\n\n\'\'\'\n# https://github.com/RoboDK/RoboDK-API/blob/master/Python/robolink.py\n# robodk_path variable to specify location of RoboDK.exe\n# under Ubuntu can not use "-NEWINSTANCE"\n\'\'\'\nstart_robodk.sh content\nLD_LIBRARY_PATH="/home/yen/RoboDK/bin/lib"\nexport LD_LIBRARY_PATH\n/home/yen/RoboDK/bin/RoboDK\n\'\'\'\nRDK = Robolink(robodk_path="/home/yen/start_robodk.sh",args=["-SKIPINI", "-EXIT_LAST_COM"])\n# Add robot and the accompanied Base coordinate\nprint(dir_path + \'/Fanuc-M-710iC-50.robot\')\n# relative directory or absolute directory will work for AddFile under Ubuntu\n#robot = RDK.AddFile(r"/home/yen/github/wcm2021/downloads/robodk/pick_and_place_kmol_mac/Fanuc-M-710iC-50.robot")\nrobot = RDK.AddFile(\'Fanuc-M-710iC-50.robot\')\n# Get the default robot base frame\nrobot_frame = RDK.Item(\'Fanuc M-710iC/50 Base\')\n# Move the base frame to the origin\nrobot_frame.setPose(transl(0,0,0))\n\n# Add a tool to an existing robot:\ntool = RDK.AddFile(dir_path + \'/MainTool.tool\', robot)\n\n# Add table 1\ntable1_frame = RDK.AddFrame(\'Table 1\')\ntable1_frame.setPose(transl(807.766544,-963.699898,41.478944))\ntable1_stl = RDK.AddFile(dir_path + \'/Table.stl\', table1_frame)\n\n# Add table 2\ntable2_frame = RDK.AddFrame(\'Table 2\')\ntable2_frame.setPose(transl(926.465508,337.151529,94.871928))\ntable2_stl = RDK.AddFile(dir_path + \'/Table.stl\', table2_frame)\n     \n# Calculate tool frames for the suction cup tool of 6 suction cups\nTCP_list = []\nfor i in range(nTCPs):\n    TCPi_pose = transl(0,0,100)*rotz((360/nTCPs)*i*pi/180)*transl(125,0,0)*roty(pi/2)\n    TCPi = robot.AddTool(TCPi_pose, \'TCP %i\' % (i+1))\n    TCP_list.append(TCPi)\n\nTCP_0 = TCP_list[0]\n\n# Turn on automatic rendering\nRDK.Render(True)\n\n# Add balls\n# create a list with 30 elements\nballs = [None for _ in range(30)]\nlayer = [16, 9, 4, 1]\ncount = 0\nfor i in range(len(balls_list)):\n    # transl(balls_list)\n    balls[i] = RDK.AddFile(\'./ball.stl\', table1_frame)\n    balls[i].setPose(transl(balls_list[i]))\n    count = count + 1\n    if count <= 16:\n        balls[i].setColor([1, 0, 0])\n    elif count > 16 and count <= 25:\n        balls[i].setColor([0, 1, 0])\n    elif count > 25 and count <=29:\n        balls[i].setColor([1, 1, 0])\n    else:\n        balls[i].setColor([0, 0, 1])\n\n# Make a list of positions to place the objects\n# ball_list is the same as frame1_list\nframe1_list = pyramid_calc(4)\nframe2_list = pyramid_calc(4)\n\n# Move balls \nrobot.setPoseTool(TCP_list[0])\nnballs_frame1 = len(frame1_list)\nnballs_frame2 = len(frame2_list)\nidTake = nballs_frame1 - 1\nidLeave = 0\nidTCP = 0\n\ntarget_app_frame = transl(2*BALL_DIAMETER, 2*BALL_DIAMETER, 4*BALL_DIAMETER)*roty(pi)*transl(0,0,-APPROACH)\n\n# frame1 is the same as table1_frame\nframe1 = RDK.Item(\'Table 1\')\nframe2 = RDK.Item(\'Table 2\')\n\nwhile idTake >= 0:\n    # ------------------------------------------------------------------\n    # first priority: grab as many balls as possible\n    # the tool is empty at this point, so take as many balls as possible (up to a maximum of 6 -> nTCPs)\n    ntake = min(nTCPs, idTake + 1)\n\n    # approach to frame 1\n    robot.setPoseFrame(frame1)\n    robot.setPoseTool(TCP_0)\n    robot.MoveJ([0,0,0,0,10,-200])\n    robot.MoveJ(target_app_frame)\n\n    # grab ntake balls from frame1\n    for i in range(ntake):\n        TCPi = TCP_list[i]\n        robot.setPoseTool(TCPi)\n        # calculate target wrt frame1: rotation about Y is needed since Z and X axis are inverted\n        target = transl(frame1_list[idTake])*roty(pi)*rotx(30*pi/180)\n        target_app = target*transl(0,0,-APPROACH)\n        idTake = idTake - 1        \n        robot.MoveL(target_app)\n        robot.MoveL(target)\n        TCP_On(TCPi, i)\n        robot.MoveL(target_app)\n \n    # ------------------------------------------------------------------\n    # second priority: unload the tool     \n    # approach to frame2 and place the tool balls into table2\n    robot.setPoseTool(TCP_0)\n    robot.MoveJ(target_app_frame)\n    robot.MoveJ([0,0,0,0,10,-200])\n    robot.setPoseFrame(frame2)    \n    robot.MoveJ(target_app_frame)\n    for i in range(ntake):\n        TCPi = TCP_list[i]\n        robot.setPoseTool(TCPi)\n        if idLeave > nballs_frame2-1:\n            raise Exception("No room left to place objects in Table 2")\n\n        # calculate target wrt frame1: rotation of 180 about Y is needed since Z and X axis are inverted\n        target = transl(frame2_list[idLeave])*roty(pi)*rotx(30*pi/180)\n        target_app = target*transl(0,0,-APPROACH)\n        idLeave = idLeave + 1        \n        robot.MoveL(target_app)\n        robot.MoveL(target)\n        TCP_Off(TCPi, i, frame2)\n        robot.MoveL(target_app)\n\n    robot.MoveJ(target_app_frame)\n\n# Move home when the robot finishes\nrobot.MoveJ([0,0,0,0,10,-200])\n \n \n', 'tags': '', 'url': 'Pick and Place.html'}, {'title': 'CoppeliaSim', 'text': 'Educational version: \n Windows: \n https://www.coppeliarobotics.com/files/CoppeliaSim_Edu_V4_1_0_Setup.exe \n https://www.coppeliarobotics.com/files/CoppeliaSim_Edu_V4_1_0_Win.zip \n Mac: \n https://www.coppeliarobotics.com/files/CoppeliaSim_Edu_V4_1_0_Mac.zip \n Ubuntu: \n https://www.coppeliarobotics.com/files/CoppeliaSim_Edu_V4_1_0_Ubuntu20_04.tar.xz \n', 'tags': '', 'url': 'CoppeliaSim.html'}, {'title': 'Arduino', 'text': 'UnoArduSim: \n https://www.sites.google.com/site/unoardusim/services \n UnoArduSimV2.9.1.zip \n Picsimlab: \n https://github.com/lcgamboa/picsimlab \n \n', 'tags': '', 'url': 'Arduino.html'}]};
var tipuesearch = {"pages": [{'title': 'About', 'text': '五專部專題題目: \n 網際內容管理系統在精密機械工程教學與研究上的應用 \n Application of Web-based Content Management Systems in Teaching and Research of Precision Mechanical Engineering \n 專題動機: \n 探討如何利用  Fossil SCM  虛擬與實體伺服器, 讓五專精密機械工程科相關師生, 得以透過學校配發的 @gm 帳號登入, 並在網際內容管理系統中進行知識管理與互動, 擬藉此提升課程教學與專題研究效益. \n 研究步驟: \n 從 Windows 與 Ubuntu 中編譯  Fossil SCM  套件開始, 分別取得 client 與 server 端的可執行檔案後, 將  Fossil SCM  安裝配置在一台實體或虛擬主機上, 利用 Python +  Flask  著手編寫  Oauth2  網際程式介面, 讓所有相關成員得以自建倉儲與網際內容管理系統, 之後再分門別類, 根據精密機械工程科學會的任務編組, 利用網際內容管理系統提供相關服務. \n 預計成果: \n \n 參與 eng.nfu.edu.tw 網域伺服器 (DNS) 與 G Suite 系統管理. \n 在 Ubuntu 虛擬主機上, 完成以  Fossil SCM  架設 pj5073.eng.nfu.edu.tw 精密機械工程科學會網站. \n 能讓獲得許可之相關人員, 透過 @gm 帳號登入科學會網站, 在各班對應網站上進行 Github 上同步網際內容管理維護或互動討論. \n 專題報告 pdf 檔案, 能夠在 github.com/mdecourse/pj5073 倉儲中的 pdf 分支, 以 Github Actions 流程發布. \n 專題簡報可直接在 mde.tw/pj5073/reveal/ 中發布. \n \n 組員: \n 50733105 \n 50733144 \n 50733146 \n 50733152 \n 四技部專題題目: \n 深度強化學習在行動機器人運動學上之應用 \n Application of Deep Reinforcement Learning in Kinematics of Mobile Robots \n 專題動機: \n 藉由研究  ECE470 專案 中行動機器人如何在  CoppeliaSim  場景中, 利用 Python remote API, 以機器視覺輔助完成避障與取放特定物件的專案內容, 並在  ref1  與  ref2  參考資料的引導下, 研究分析深度強化學習架構該如何在行動機器人運動學上進行應用. \n 研究步驟: \n \n 將  ECE470 專案 內容分別配置於 Windows 與 Ubuntu 環境中, 重現 Python remote API 控制場景, 完成避障與取放特定物件任務. \n 延伸 Python remote API, 改用  B0-based remote API  完成避障與取放特定物件任務. \n 延伸上述  CoppeliaSim  控制場景, 在 Ubuntu 上以  headless  啟動, 並將場景影像以  Flask  串流至 client 端瀏覽器. \n 在 Ubuntu 實體與虛擬主機上建立 pj2022.kmol.info 主機, 設法編寫轉檔程式 (主要修改 init.py, config/config 檔案設定內容), 讓自架主機上的倉儲內容能夠同時支援近端 (同步內容推送至 Github, Gitlab, Bitbucket 與 Heroku) 與  uwsgi  伺服. \n 研究如何利用機器視覺與深度強化學習 ( ref1 ,  ref2 ,  ref3 )提升避障與取放特定物件效能. \n \n 預計成果: \n \n 完成 pj2022.kmol.info 主機架設, 使用者可從瀏覽器登入行動機器人場景執行監控. \n pj2022 專題網站內容可同步至 Github Pages, Gitlab Pages, 自架  Fossil SCM  主機與 Heroku 主機. \n 專題報告 pdf 檔案, 能夠在 github.com/mdecourse/pj2022 倉儲中的 pdf 分支, 以 Github Actions 流程發布. \n 專題報告內容能直接透過 Github Actions 套用  IEEE 論文格式 進行 5-7 頁論文 Release 發布. \n 專題簡報可直接在 mde.tw/pj2022/reveal/ 中發布. \n \n 組員: \n 40823116 \n 40823131 \n 40823152 \n 40823153 \n \n 4072 專題: \n https://github.com/mdecourse/4072pj1  ( 強化學習在機電系統中之應用 ) \n https://github.com/mdecourse/4072pj2  ( 有限元素分析套件解析應用 ) \n https://github.com/mdecourse/4072pj3  ( Pyslvs-UI 平面多連桿機構套件之合成與應用 ) \n \n 工作站室虛擬主機: \n nginx: sudo /etc/init.d/nginx restart \n uwsgi: sudo systemctl restart cmsimde \n fossil scm: sudo /etc/init.d/stunnel4 restart \n 研究項目: \n \n 在實體或虛擬主機上配置 Ubuntu Desktop 操作系統, 並配置網際應用程式伺服器 \n 能夠透過程式方法建立虛擬環境中的機電資整合系統 \n 能夠透過網際與機器學習手段, 利用網路遠端監控虛擬整合機電資系統 \n \n 具體工作項目: \n \n 利用虛擬主機安裝 Ubuntu Desktop 操作系統, 並在其中配置 cmstemplate 網際內容管理系統, RoboDK, CoppeliaSim, Webots 等系統 \n 利用 Windows 10 上的 Xming, 遠端啟動 RoboDK, CoppeliaSim 與 Webots 等系統. \n 利用 Python remote API 操控網際應用程式伺服器上的 RoboDK, CoppeliaSim 與 Webots 機電整合場景 \n 利用 Python 程式根據 RoKiSim Industrial Robot 定義 (XML +STL), 將所有 Robot 系統轉入 CoppeliaSim 與 Webots 執行 Forward and Inverse Kinematic 操作 \n 利用機器視覺與學習方法在近端進行機械手臂自動化操作 \n 利用網際架構監控虛實整合機電系統 \n \n 了解  RoKiSim.7z  中有關 CAD_Robots 目錄中有關 XML 與 STL 組成 Robot 的定義, 然後根據  abbirm.simscene.xml.zip  中 CoppeliaSim XML 檔案格式, 以程式方法將所有 Robots 轉為 CoppeliaSim 場景中的 ttm 模型. 以執行 Forward and Inverse Knimatic 運動操作.', 'tags': '', 'url': 'About.html'}, {'title': '網際內容管理', 'text': '能夠自己架設 網際內容管理系統 所需的軟硬體與網路配置後, 再加上遠端 Github 與近端 Fossil SCM 資料同步的分散式版次管理系統整合後, 想要從事哪一類的科技研究, 應該就沒有後顧之憂了, 而且各成員大多時間都能在網路上進行協同, 只有少部分時間必須配合硬體主機的實體維護與配置操作. \n 假如將自行架設的主機以付費的主機代管或雲端主機服務取代, 則各成員皆可全時在網路上進行協同. \n 以下是與強化學習及碎片回復有關的參考資料: \n Reinforcement Learning - An Introduction.pdf \n Playing Atari with Deep Reinforcement Learning.pdf \n Reconstructing Shredded Documents.pdf \n Reconstruction of Shredded Paper Documents byFeature Matching.pdf \n Faster_Reconstruction_of_Shredded_Text_Documents_via_Self-Supervised_Deep_Asymmetric_CVPR_2020_paper.pdf \n Regenerate the Shredded Documents by using Memetic Algorithm.pdf', 'tags': '', 'url': '網際內容管理.html'}, {'title': '虛實整合', 'text': '透過網際內容管理主機上配置能與實體系統真實對應的模擬環境後, 使用者可以從多台裝置上的瀏覽器監控虛擬或實體機電資整合系統. \n 所需技術: \n \n 網際內容管理主機上配置虛擬環境 \n 該虛擬機電資整合環境可以透過製造流程成為實體系統 \n 虛擬環境中的場景影像可以串流至使用者網路裝置上的瀏覽器或 APPs \n 使用者可以監控虛擬或實體機電資整合系統 \n', 'tags': '', 'url': '虛實整合.html'}, {'title': '機器學習', 'text': '\n 機器可以透過影像裝置取得外部物件座標系統 \n 電腦可以透過該物件座標系統取放物件 \n 機電資系統可以透過強化學習完成既定工作項目 \n', 'tags': '', 'url': '機器學習.html'}, {'title': 'DRLKMR', 'text': '四技專題題目 \n 深度強化學習在行動機器人運動學上之應用 \n Application of Deep Reinforcement Learning in Kinematics of Mobile Robots (DRLKMR) \n 工作任務: \n 以  MSYS2  編譯  CoppeliaSim : \n 建立可編譯  CoppeliaSim  的可攜程式環境. \n 倉儲:\xa0 https://github.com/CoppeliaRobotics \xa0 \n 由於 CoppeliaSim 4.2.0 re6 將進行 lua 程式介接的改寫, 整體架構將會與先前的版本有很大差異. \n 目前希望針對 CoppeliaSim 4.2.0 rev5 的版本執行編譯( 核心程式庫倉儲 ), 所採用的 Lua 為 5.3.5 版(可從  https://www.lua.org/ftp/  下載). 至於從  https://riverbankcomputing.com/software/qscintilla/download , 可以發現 QScintilla gpl 版本僅釋出至 2.12.2, 因此只能採用  QScintilla_gpl-2.11.2.zip . \n 先編譯  Lua , 再編譯  QScintilla_gpl-2.11.2 , 接著編譯\xa0 CoppeliaSimlib  與  coppeliasimClientAppllication \n 過程中需要 programming 目錄中的  common ,  include  與  simMath \n 取得 coppeliaSim.dll 與 coppeliaSim.exe 後再利用  Dependencies  複製所需 dll 後, 透過  MSYS2  安裝的  Qt5 plugins platforms  環境變數設定後啟動 CoppeliaSim. \n 核心程式庫 \n ClientApplication \n 從 4.2.0 rev5 下載安裝套件中取得 programming 目錄中的檔案內容, 其中最重要的是 system, platforms, models, scenes, lua, luar 等目錄. \n 編譯完成 coppeliaSim.dll, coppeliaSim.exe 後, 配合 programming 目錄內容與所需的 dll 動態連結程式庫後, CoppeliaSim 已經可以開啟, 但是若要執行 Lua scripting, 還需要  simExtGeom , 若要套用 Inverse Kinematics 則需要  simExtIK , 至於要開啟 Object 附屬的 Lua 程式編輯器, 則需要  simExtCodeEditor . \n 取得結果: \n 可編譯執行  CoppeliaSim  的可攜程式環境 \n 自行編譯的  CoppeliaSim  4.2.0 rev5 程式套件 \n 利用  vrep-env  完成冰球機在 Windows 環境的強化學習訓練 \n \n Portable compiler in Windows 64-bit operating system.  compile_copsim.7z , download file size 3.87 GB, uncompressed file size 14 GB) \n 有關 V-rep 3.1.2 的  Lua 與 C++ 編譯練習 . \n 參考資料: \n Robotic assembly using Deep Reinforcement Learning \n An Introduction to Deep Reinforcement Learning  (140頁電子書) \n Tutorial: Deep Reinforcement Learning  (66 頁簡報) \n Intro to Deep Reinforcement Learning \n Deep Reinforcement Learning Fundamentals, Research and Applications \n Playing Atari with Deep Reinforcement Learning \n Deep Reinforcement Learning  (只有章節標題與程式碼) \n https://github.com/deep-reinforcement-learning-book/Chapter16-Robot-Learning-in-Simulation \n 利用 Elixir 建立自駕車 DRL \n https://github.com/marceloreichert/pwt-autonomous-car-medium', 'tags': '', 'url': 'DRLKMR.html'}, {'title': '建立可攜系統', 'text': 'Python 3.9.5  (下載 203MB, 解開壓縮 880MB) - 主要執行 Leo Editor 進行程式開發. \n Portablegit 2.31.1  (下載 58MB, 解開壓縮 272MB) - Git 工具. \n SciTE 5.0.2  (下載 1.3MB, 解開壓縮 4.3MB) - 編輯並執行 Python, TinyC, Lua 等程式. \n Lua5.4.3  (下載 635KB, 解開壓縮 2.85MB) - Lua 解譯系統. \n MSYS2 20210419  (下載 3.33GB, 解開壓縮 12GB) - 用於編譯 Qt5 C++ 程式碼. \n Boost 1.76.0  (下載 93MB, 解開壓縮 680MB) - C++ 程式庫. \n cmake 3.10.1  (下載 10.7MB, 解開壓縮 61MB) - build C++ 程式套件. \n Qscintilla 2.11.2  (下載 3.7MB, 解開壓縮 32.8MB) - editor control 程式庫. \n eigen 3.3.8  (下載 1.4MB, 解開壓縮 11.5MB) - eigenvalue 運算程式庫. \n Dependencies  (下載 2.7MB, 解開壓縮 12.4MB) - 查詢 exe 與 dll 檔案執行相依程式庫. \n start and stop batch  - 啟動關閉與設定檔案.', 'tags': '', 'url': '建立可攜系統.html'}, {'title': 'pj2022', 'text': 'http://mally.stanford.edu/~sr/computing/basic-unix.html \n 這台主機是採用 Ubuntu 20.04 Desktop 最小安裝後, 配置 CMSiMDE 動態網站在 uwsgi + nginx 的 https www server 的環境中啟動, 而靜態網頁則直接配置於 http nginx server. \n 之後為了讓使用者可以遠端 ssh 至主機, 另外安裝 openssh-server. \n Fossil SCM 則透過 stunnel 提供的 https 進行 port 5443 的 serving. 但目前上述動態與靜態 CMSiMDE 並未與近端 Fossil SCM 及遠端 Github 倉儲進行同步整合. \n 由於這台主機具備桌面系統, 因此使用者可以透過  https://sourceforge.net/projects/xming/  以 X-windows 取得在server 執行的程式畫面, 其中包括  RoboDK  與  CoppeliaSim . \n 上述配置可以搭配: \n https://ctmakro.github.io/site/on_learning/rl/vrep.html \n https://medium.com/pytorch/robotic-assembly-using-deep-reinforcement-learning-dfd9916c5ad7 \n https://github.com/stepjam/PyRep \n 進行機電整合系統的機器學習研究. \n Change init.py title to "Pj5073", need to use "sudo systemctl restart cmsimde" to make it work.', 'tags': '', 'url': 'pj2022.html'}, {'title': 'upgrade', 'text': 'sudo apt update \n sudo apt upgrade \n sudo apt dist-upgrade \n sudo do-release-upgrade \n /etc/update-manager/release-upgrades file \n Prompt=lts or normal \n 因為 Range3 無法在 Ubuntu 20.04 項下的 libqt5core5a 程式庫版本中執行 5.12, 必須升級為 Ubuntu 21.04 才可以安裝 5.15 以上的 libqt5core5a. \n 2021.05.16 16:59 正在升級為 Ubuntu 21.04 過程中. \n', 'tags': '', 'url': 'upgrade.html'}, {'title': '強化學習', 'text': 'Pytorch: \n Pytorch Tutorial.pdf \n Pytorch_Tutorial_1.pdf \n Introduction_to_DL_with_PyTorch.pdf \n PyTorch- An Imperative Style High-PerformanceDeep Learning Library.pdf \n Deep Learning with Pytorch.pdf \n Pytorch Recipes  (校園網路中下載) \n https://github.com/thu-ml/tianshou  (天授 Pytorch Deep Reinforcement Learning Library) \n Reinforcement Learning: \n Reinforce Learning - An Introduction.pdf \n A Reinforcement Learning Approach to View Planning forAutomated Inspection Tasks.pdf \n https://github.com/jhu-lcsr/good_robot  (Efficient Reinforcement Learning for Multi-Step Visual Tasks with Sim to Real Transfer) \n Deep Reinforcement Learning \n Introduction to Deep Reinforcement Learning0.pdf \n Tutorial of Deep Reinforcement Learning.pdf \n An Introduction to Deep Reinforcement Learning.pdf \n An Introduction To Deep Reinforcement Learning2.pdf \n An Introduction to Deep Reinforcement Learning3.pdf \n Deep Reinforcement Learning with InteractiveFeedback in a Human–Robot Environment.pdf \n A Collision Avoidance Method Based on DeepReinforcement Learning.pdf \n Experimental investigations of a highlymaneuverable mobile omniwheel robot.pdf \n Deep reinforcement learning for robotic manipulation with asynchronous off-policy updates  (在校園網路中下載) \n Deep Reinforcement Learning  (校園網路中下載) \n https://github.com/deep-reinforcement-learning-book \n Pyrep: \n https://github.com/stepjam/PyRep \n https://github.com/deep-reinforcement-learning-book/Chapter16-Robot-Learning-in-Simulation \n https://github.com/chauby/V-REP-YouBot-Demo \n https://github.com/Souphis/gym-vrep \n A Big CAD model dataset: \n https://archive.nyu.edu/handle/2451/43778', 'tags': '', 'url': '強化學習.html'}, {'title': '相關技術', 'text': 'Learning Kinematic Feasibility through Reinforcement Learning \n Learning Kinematic Feasibility for MobileManipulation through Deep Reinforcement Learning.pdf \n https://github.com/robot-learning-freiburg/kinematic-feasibility-rl \n https://rl.uni-freiburg.de/demos-datasets-software \n Fundamentals of Manipulator Calibration:  https://core.ac.uk/download/pdf/36732657.pdf', 'tags': '', 'url': '相關技術.html'}, {'title': 'X Window', 'text': '在 Windows 10 中可以使用  Xming  X server. 其目的在讓遠端的伺服器執行 GUI 程式時, 能將圖型介面傳送至 X server. \n 利用  Xming  帶出 pj5073.kmol.info 上所執行的程式 GUI 畫面流程: \n \n 設定以 putty.exe 對 pj5073.kmol.info ssh 連線 \n 連線 session 之 SSH -> Auth ->X11 勾選 enable X11 Forwarding, 並將 X Display location 設為 localhost:0.0, 表示要將程式執行的畫面傳回 X server. \n ssh  user_account@pj5073.kmol.info  連線後, 以 xterm& 背景執行 xterm. \n 接著以 nautilus& 背景執行 Ubuntu 的 GUI 檔案瀏覽器. \n \n', 'tags': '', 'url': 'X Window.html'}, {'title': 'RoboDK', 'text': 'Windows 64 位元: \n https://robodk.com/downloads/Install-RoboDK-64-v5.2.3.exe \n Mac 64 位元: \n https://robodk.com/downloads/Install-RoboDK.dmg \n Ubuntu 64 位元: \n https://robodk.com/downloads/Install-RoboDK.tar.gz \n Raspberry Pi: \n https://robodk.com/downloads/Install-RoboDK-Pi.tar.gz \n Android: \n https://play.google.com/store/apps/details?id=org.robodk.app.sharex \n iPhone: \n https://apps.apple.com/lc/app/robodk/id1485169308 \n', 'tags': '', 'url': 'RoboDK.html'}, {'title': 'RoboDK API', 'text': 'get CWD: \n import os\n\n# Get the current working directory\n\nCWD = os.path.dirname(os.path.realpath(__file__)) \n Under Ubuntu \n /usr/local/lib/python3.8/dist-packages/robolink/robolink.py \n and \n /usr/local/lib/python3.8/dist-packages/robodk/robodk.py \n replaced with the newest source codes of  https://github.com/RoboDK/RoboDK-API/tree/master/Python \n from robolink import *\nfrom robodk import *\n\nimport os\n\ndir_path = os.path.dirname(os.path.realpath(__file__))\nprint(dir_path)\n# Calculate pyramid coordinate\n\ndef pyramid_calc(BALLS_SIDE=4):\n    """Calculate a list of points (ball center) as if the balls were place in a pyramid"""\n    #the number of balls can be calculated as: int(BALLS_SIDE*(BALLS_SIDE+1)*(2*BALLS_SIDE+1)/6)\n    BALL_DIAMETER = 100\n    xyz_list = []\n    sqrt2 = 2**(0.5)\n    for h in range(BALLS_SIDE):\n        for i in range(BALLS_SIDE-h):\n            for j in range(BALLS_SIDE-h):\n                height = h*BALL_DIAMETER/sqrt2 + BALL_DIAMETER/2\n                xyz_list = xyz_list + [[i*BALL_DIAMETER + (h+1)*BALL_DIAMETER*0.5, j*BALL_DIAMETER + (h+1)*BALL_DIAMETER*0.5, height]]\n    return xyz_list\n    \n\n# Make a list of positions to place the objects\nballs_list = pyramid_calc(4)\n\n#print(len(frame1_list))\n# 4*4 = 16\n# 3*3 = 9\n# 2*2 = 4\n# 1+4+9+16 = 30\n\n# height 50*sqrt(2)\n\'\'\'\n[\n\n[50.0, 50.0, 50.0], [50.0, 150.0, 50.0], [50.0, 250.0, 50.0], [50.0, 350.0, 50.0], \n\n[150.0, 50.0, 50.0], [150.0, 150.0, 50.0], [150.0, 250.0, 50.0], [150.0, 350.0, 50.0], \n\n[250.0, 50.0, 50.0], [250.0, 150.0, 50.0], [250.0, 250.0, 50.0], [250.0, 350.0, 50.0], \n\n[350.0, 50.0, 50.0], [350.0, 150.0, 50.0], [350.0, 250.0, 50.0], [350.0, 350.0, 50.0], \n\n\n[100.0, 100.0, 120.71067811865474], [100.0, 200.0, 120.71067811865474], [100.0, 300.0, 120.71067811865474], \n\n[200.0, 100.0, 120.71067811865474], [200.0, 200.0, 120.71067811865474], [200.0, 300.0, 120.71067811865474], \n\n[300.0, 100.0, 120.71067811865474], [300.0, 200.0, 120.71067811865474], [300.0, 300.0, 120.71067811865474], \n\n\n[150.0, 150.0, 191.42135623730948], [150.0, 250.0, 191.42135623730948], \n\n[250.0, 150.0, 191.42135623730948], [250.0, 250.0, 191.42135623730948], \n\n\n[200.0, 200.0, 262.13203435596427]\n\n]\n\n\'\'\'\n# https://github.com/RoboDK/RoboDK-API/blob/master/Python/robolink.py\n# robodk_path variable to specify location of RoboDK.exe\n# under Ubuntu can not use "-NEWINSTANCE"\n\'\'\'\nstart_robodk.sh content\nLD_LIBRARY_PATH="/home/yen/RoboDK/bin/lib"\nexport LD_LIBRARY_PATH\n/home/yen/RoboDK/bin/RoboDK\n\'\'\'\nRDK = Robolink(robodk_path="/home/yen/start_robodk.sh",args=["-SKIPINI", "-EXIT_LAST_COM"])\n# Add robot and the accompanied Base coordinate\nprint(dir_path + \'/Fanuc-M-710iC-50.robot\')\n# relative directory or absolute directory will work for AddFile under Ubuntu\n#robot = RDK.AddFile(r"/home/yen/github/wcm2021/downloads/robodk/pick_and_place_kmol_mac/Fanuc-M-710iC-50.robot")\nrobot = RDK.AddFile(\'Fanuc-M-710iC-50.robot\')\n# Get the default robot base frame\nrobot_frame = RDK.Item(\'Fanuc M-710iC/50 Base\')\n# Move the base frame to the origin\nrobot_frame.setPose(transl(0,0,0))\n\n# Add a tool to an existing robot:\ntool = RDK.AddFile(dir_path + \'/MainTool.tool\', robot)\n\n# Add table 1\ntable1_frame = RDK.AddFrame(\'Table 1\')\ntable1_frame.setPose(transl(807.766544,-963.699898,41.478944))\ntable1_stl = RDK.AddFile(dir_path + \'/Table.stl\', table1_frame)\n\n# Add table 2\ntable2_frame = RDK.AddFrame(\'Table 2\')\ntable2_frame.setPose(transl(926.465508,337.151529,94.871928))\ntable2_stl = RDK.AddFile(dir_path + \'/Table.stl\', table2_frame)\n\n# Add balls\n# create a list with 30 elements\nballs = [None for _ in range(30)]\nlayer = [16, 9, 4, 1]\ncount = 0\nfor i in range(len(balls_list)):\n    # transl(balls_list)\n    balls[i] = RDK.AddFile(\'./ball.stl\', table2_frame)\n    balls[i].setPose(transl(balls_list[i]))\n    count = count + 1\n    if count <= 16:\n        balls[i].setColor([1, 0, 0])\n    elif count > 16 and count <= 25:\n        balls[i].setColor([0, 1, 0])\n    elif count > 25 and count <=29:\n        balls[i].setColor([1, 1, 0])\n    else:\n        balls[i].setColor([0, 0, 1])\n \n', 'tags': '', 'url': 'RoboDK API.html'}, {'title': 'Pick and Place', 'text': 'Use RoboDK Python API create Pick and Place simulation: \n from robolink import *\nfrom robodk import *\n\nimport os\n\ndir_path = os.path.dirname(os.path.realpath(__file__))\nprint(dir_path)\n# Calculate pyramid coordinate\n\n# Setup global parameters\nBALL_DIAMETER = 100 # diameter of one ball\nAPPROACH = 100      # approach distance to grab each part, in mm\nnTCPs = 6           # number of TCP\'s in the tool\n\ndef pyramid_calc(BALLS_SIDE=4):\n    """Calculate a list of points (ball center) as if the balls were place in a pyramid"""\n    #the number of balls can be calculated as: int(BALLS_SIDE*(BALLS_SIDE+1)*(2*BALLS_SIDE+1)/6)\n    #BALL_DIAMETER = 100\n    xyz_list = []\n    sqrt2 = 2**(0.5)\n    for h in range(BALLS_SIDE):\n        for i in range(BALLS_SIDE-h):\n            for j in range(BALLS_SIDE-h):\n                height = h*BALL_DIAMETER/sqrt2 + BALL_DIAMETER/2\n                xyz_list = xyz_list + [[i*BALL_DIAMETER + (h+1)*BALL_DIAMETER*0.5, j*BALL_DIAMETER + (h+1)*BALL_DIAMETER*0.5, height]]\n    return xyz_list\n    \ndef TCP_On(toolitem, tcp_id):\n    """Attach the closest object to the toolitem Htool pose,\n    furthermore, it will output appropriate function calls on the generated robot program (call to TCP_On)"""\n    toolitem.AttachClosest()\n    toolitem.RDK().RunMessage(\'Set air valve %i on\' % (tcp_id+1))\n    toolitem.RDK().RunProgram(\'TCP_On(%i)\' % (tcp_id+1));\n        \ndef TCP_Off(toolitem, tcp_id, itemleave=0):\n    """Detaches the closest object attached to the toolitem Htool pose,\n    furthermore, it will output appropriate function calls on the generated robot program (call to TCP_Off)"""\n    toolitem.DetachAll(itemleave)\n    toolitem.RDK().RunMessage(\'Set air valve %i off\' % (tcp_id+1))\n    toolitem.RDK().RunProgram(\'TCP_Off(%i)\' % (tcp_id+1));\n\n# Make a list of positions to place the objects\nballs_list = pyramid_calc(4)\n\n#print(len(frame1_list))\n# 4*4 = 16\n# 3*3 = 9\n# 2*2 = 4\n# 1+4+9+16 = 30\n\n# height 50*sqrt(2)\n\'\'\'\n[\n\n[50.0, 50.0, 50.0], [50.0, 150.0, 50.0], [50.0, 250.0, 50.0], [50.0, 350.0, 50.0], \n\n[150.0, 50.0, 50.0], [150.0, 150.0, 50.0], [150.0, 250.0, 50.0], [150.0, 350.0, 50.0], \n\n[250.0, 50.0, 50.0], [250.0, 150.0, 50.0], [250.0, 250.0, 50.0], [250.0, 350.0, 50.0], \n\n[350.0, 50.0, 50.0], [350.0, 150.0, 50.0], [350.0, 250.0, 50.0], [350.0, 350.0, 50.0], \n\n\n[100.0, 100.0, 120.71067811865474], [100.0, 200.0, 120.71067811865474], [100.0, 300.0, 120.71067811865474], \n\n[200.0, 100.0, 120.71067811865474], [200.0, 200.0, 120.71067811865474], [200.0, 300.0, 120.71067811865474], \n\n[300.0, 100.0, 120.71067811865474], [300.0, 200.0, 120.71067811865474], [300.0, 300.0, 120.71067811865474], \n\n\n[150.0, 150.0, 191.42135623730948], [150.0, 250.0, 191.42135623730948], \n\n[250.0, 150.0, 191.42135623730948], [250.0, 250.0, 191.42135623730948], \n\n\n[200.0, 200.0, 262.13203435596427]\n\n]\n\n\'\'\'\n# https://github.com/RoboDK/RoboDK-API/blob/master/Python/robolink.py\n# robodk_path variable to specify location of RoboDK.exe\n# under Ubuntu can not use "-NEWINSTANCE"\n\'\'\'\nstart_robodk.sh content\nLD_LIBRARY_PATH="/home/yen/RoboDK/bin/lib"\nexport LD_LIBRARY_PATH\n/home/yen/RoboDK/bin/RoboDK\n\'\'\'\nRDK = Robolink(robodk_path="/home/yen/start_robodk.sh",args=["-SKIPINI", "-EXIT_LAST_COM"])\n# Add robot and the accompanied Base coordinate\nprint(dir_path + \'/Fanuc-M-710iC-50.robot\')\n# relative directory or absolute directory will work for AddFile under Ubuntu\n#robot = RDK.AddFile(r"/home/yen/github/wcm2021/downloads/robodk/pick_and_place_kmol_mac/Fanuc-M-710iC-50.robot")\nrobot = RDK.AddFile(\'Fanuc-M-710iC-50.robot\')\n# Get the default robot base frame\nrobot_frame = RDK.Item(\'Fanuc M-710iC/50 Base\')\n# Move the base frame to the origin\nrobot_frame.setPose(transl(0,0,0))\n\n# Add a tool to an existing robot:\ntool = RDK.AddFile(dir_path + \'/MainTool.tool\', robot)\n\n# Add table 1\ntable1_frame = RDK.AddFrame(\'Table 1\')\ntable1_frame.setPose(transl(807.766544,-963.699898,41.478944))\ntable1_stl = RDK.AddFile(dir_path + \'/Table.stl\', table1_frame)\n\n# Add table 2\ntable2_frame = RDK.AddFrame(\'Table 2\')\ntable2_frame.setPose(transl(926.465508,337.151529,94.871928))\ntable2_stl = RDK.AddFile(dir_path + \'/Table.stl\', table2_frame)\n     \n# Calculate tool frames for the suction cup tool of 6 suction cups\nTCP_list = []\nfor i in range(nTCPs):\n    TCPi_pose = transl(0,0,100)*rotz((360/nTCPs)*i*pi/180)*transl(125,0,0)*roty(pi/2)\n    TCPi = robot.AddTool(TCPi_pose, \'TCP %i\' % (i+1))\n    TCP_list.append(TCPi)\n\nTCP_0 = TCP_list[0]\n\n# Turn on automatic rendering\nRDK.Render(True)\n\n# Add balls\n# create a list with 30 elements\nballs = [None for _ in range(30)]\nlayer = [16, 9, 4, 1]\ncount = 0\nfor i in range(len(balls_list)):\n    # transl(balls_list)\n    balls[i] = RDK.AddFile(\'./ball.stl\', table1_frame)\n    balls[i].setPose(transl(balls_list[i]))\n    count = count + 1\n    if count <= 16:\n        balls[i].setColor([1, 0, 0])\n    elif count > 16 and count <= 25:\n        balls[i].setColor([0, 1, 0])\n    elif count > 25 and count <=29:\n        balls[i].setColor([1, 1, 0])\n    else:\n        balls[i].setColor([0, 0, 1])\n\n# Make a list of positions to place the objects\n# ball_list is the same as frame1_list\nframe1_list = pyramid_calc(4)\nframe2_list = pyramid_calc(4)\n\n# Move balls \nrobot.setPoseTool(TCP_list[0])\nnballs_frame1 = len(frame1_list)\nnballs_frame2 = len(frame2_list)\nidTake = nballs_frame1 - 1\nidLeave = 0\nidTCP = 0\n\ntarget_app_frame = transl(2*BALL_DIAMETER, 2*BALL_DIAMETER, 4*BALL_DIAMETER)*roty(pi)*transl(0,0,-APPROACH)\n\n# frame1 is the same as table1_frame\nframe1 = RDK.Item(\'Table 1\')\nframe2 = RDK.Item(\'Table 2\')\n\nwhile idTake >= 0:\n    # ------------------------------------------------------------------\n    # first priority: grab as many balls as possible\n    # the tool is empty at this point, so take as many balls as possible (up to a maximum of 6 -> nTCPs)\n    ntake = min(nTCPs, idTake + 1)\n\n    # approach to frame 1\n    robot.setPoseFrame(frame1)\n    robot.setPoseTool(TCP_0)\n    robot.MoveJ([0,0,0,0,10,-200])\n    robot.MoveJ(target_app_frame)\n\n    # grab ntake balls from frame1\n    for i in range(ntake):\n        TCPi = TCP_list[i]\n        robot.setPoseTool(TCPi)\n        # calculate target wrt frame1: rotation about Y is needed since Z and X axis are inverted\n        target = transl(frame1_list[idTake])*roty(pi)*rotx(30*pi/180)\n        target_app = target*transl(0,0,-APPROACH)\n        idTake = idTake - 1        \n        robot.MoveL(target_app)\n        robot.MoveL(target)\n        TCP_On(TCPi, i)\n        robot.MoveL(target_app)\n \n    # ------------------------------------------------------------------\n    # second priority: unload the tool     \n    # approach to frame2 and place the tool balls into table2\n    robot.setPoseTool(TCP_0)\n    robot.MoveJ(target_app_frame)\n    robot.MoveJ([0,0,0,0,10,-200])\n    robot.setPoseFrame(frame2)    \n    robot.MoveJ(target_app_frame)\n    for i in range(ntake):\n        TCPi = TCP_list[i]\n        robot.setPoseTool(TCPi)\n        if idLeave > nballs_frame2-1:\n            raise Exception("No room left to place objects in Table 2")\n\n        # calculate target wrt frame1: rotation of 180 about Y is needed since Z and X axis are inverted\n        target = transl(frame2_list[idLeave])*roty(pi)*rotx(30*pi/180)\n        target_app = target*transl(0,0,-APPROACH)\n        idLeave = idLeave + 1        \n        robot.MoveL(target_app)\n        robot.MoveL(target)\n        TCP_Off(TCPi, i, frame2)\n        robot.MoveL(target_app)\n\n    robot.MoveJ(target_app_frame)\n\n# Move home when the robot finishes\nrobot.MoveJ([0,0,0,0,10,-200])\n \n \n', 'tags': '', 'url': 'Pick and Place.html'}, {'title': 'CoppeliaSim', 'text': 'Educational version: \n Windows: \n https://www.coppeliarobotics.com/files/CoppeliaSim_Edu_V4_1_0_Setup.exe \n https://www.coppeliarobotics.com/files/CoppeliaSim_Edu_V4_1_0_Win.zip \n Mac: \n https://www.coppeliarobotics.com/files/CoppeliaSim_Edu_V4_1_0_Mac.zip \n Ubuntu: \n https://www.coppeliarobotics.com/files/CoppeliaSim_Edu_V4_1_0_Ubuntu20_04.tar.xz \n', 'tags': '', 'url': 'CoppeliaSim.html'}, {'title': 'Arduino', 'text': 'UnoArduSim: \n https://www.sites.google.com/site/unoardusim/services \n UnoArduSimV2.9.1.zip \n Picsimlab: \n https://github.com/lcgamboa/picsimlab \n \n', 'tags': '', 'url': 'Arduino.html'}]};